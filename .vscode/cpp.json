{
    "dcpp": {
        "prefix": "dcpp",
        "body": [
            "#pragma GCC optimize(\"Ofast,unroll-loops,no-stack-protector,fast-math,inline\")",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "using ll = int64_t;",
            "using ull = uint64_t;",
            "using uint = uint32_t;",
            "using i8 = int8_t;",
            "using u8 = uint8_t;",
            "using ish = int16_t;",
            "using ush = uint16_t;",
            "",
            "const ll MOD = 1e9 + 7;",
            "const ll OMOD = 998'244'353;",
            "",
            "#if defined(LOCAL)",
            "#include \"debug.h\"",
            "#else",
            "#define clg(...)",
            "#endif",
            "",
            "void solve() {",
            "\t$0",
            "}",
            "",
            "int32_t main() {",
            "#ifdef CDEBUG",
            "\tfreopen(\"input.txt\", \"r\", stdin);",
            "\tfreopen(\"output.txt\", \"w\", stdout);",
            "\t// freopen(\"error.txt\", \"w\", stderr);",
            "#endif",
            "\tios::sync_with_stdio(0);",
            "\tcin.tie(0);",
            "\tint tc = 1;",
            "\tcin >> tc;",
            "\tfor (int i = 1; i <= tc; ++i) {",
            "\t\tsolve();",
            "\t}",
            "\treturn 0;",
            "}"
        ]
    },
    "prime_factorize_not_in_power_form": {
        "prefix": "prime_factorize_not_in_power_form",
        "body": [
            "uint32_t rand_int() {",
            "\tstatic uint32_t x = 123456789, y = 362436069, z = 521288629, w = 88675123;",
            "\tuint32_t t = x ^ (x << 11);",
            "\tx = y;",
            "\ty = z;",
            "\tz = w;",
            "\treturn w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));",
            "}",
            "namespace SPRP {",
            "\tconst std::vector<std::vector<__int128>> bases{",
            "\t\t{126401071349994536},\t\t\t\t\t\t\t   // < 291831",
            "\t\t{336781006125, 9639812373923155},\t\t\t\t   // < 1050535501 (1e9)",
            "\t\t{2, 2570940, 211991001, 3749873356},\t\t\t\t// < 47636622961201 (4e13)",
            "\t\t{2, 325, 9375, 28178, 450775, 9780504, 1795265022}  // <= 2^64",
            "\t};",
            "\tinline int get_id(long long n) {",
            "\t\tif (n < 291831) {",
            "\t\t\treturn 0;",
            "\t\t} else if (n < 1050535501) {",
            "\t\t\treturn 1;",
            "\t\t} else if (n < 47636622961201)",
            "\t\t\treturn 2;",
            "\t\telse {",
            "\t\t\treturn 3;",
            "\t\t}",
            "\t}",
            "}  // namespace SPRP",
            "",
            "// Complexity: O(lg n) per query",
            "struct {",
            "\tlong long modpow(__int128 x, __int128 n, long long mod) noexcept {",
            "\t\t__int128 ret = 1;",
            "\t\tfor (x %= mod; n; x = x * x % mod, n >>= 1) ret = (n & 1) ? ret * x % mod : ret;",
            "\t\treturn ret;",
            "\t}",
            "\tbool operator()(long long n) noexcept {",
            "\t\tif (n < 2) return false;",
            "\t\tif (n % 2 == 0) return n == 2;",
            "\t\tint s = __builtin_ctzll(n - 1);",
            "",
            "\t\tfor (__int128 a : SPRP::bases[SPRP::get_id(n)]) {",
            "\t\t\tif (a % n == 0) continue;",
            "\t\t\ta = modpow(a, (n - 1) >> s, n);",
            "\t\t\tbool may_composite = true;",
            "\t\t\tif (a == 1) continue;",
            "\t\t\tfor (int r = s; r--; a = a * a % n) {",
            "\t\t\t\tif (a == n - 1) may_composite = false;",
            "\t\t\t}",
            "\t\t\tif (may_composite) return false;",
            "\t\t}",
            "\t\treturn true;",
            "\t}",
            "} is_prime;",
            "",
            "struct {",
            "\tlong long find_factor(long long n) {",
            "\t\tassert(n > 1);",
            "\t\tif (n % 2 == 0) return 2;",
            "\t\tif (is_prime(n)) return n;",
            "\t\tlong long c = 1;",
            "\t\tauto f = [&](__int128 x) -> long long { return (x * x + c) % n; };",
            "",
            "\t\tfor (int t = 1;; t++) {",
            "\t\t\tfor (c = 0; c == 0 or c + 2 == n;) c = rand_int() % n;",
            "\t\t\tlong long x0 = t, m = std::max(n >> 3, 1LL), x, ys, y = x0, r = 1, g, q = 1;",
            "\t\t\tdo {",
            "\t\t\t\tx = y;",
            "\t\t\t\tfor (int i = r; i--;) y = f(y);",
            "\t\t\t\tlong long k = 0;",
            "\t\t\t\tdo {",
            "\t\t\t\t\tys = y;",
            "\t\t\t\t\tfor (int i = std::min(m, r - k); i--;) y = f(y), q = __int128(q) * std::abs(x - y) % n;",
            "\t\t\t\t\tg = std::__gcd<long long>(q, n);",
            "\t\t\t\t\tk += m;",
            "\t\t\t\t} while (k < r and g <= 1);",
            "\t\t\t\tr <<= 1;",
            "\t\t\t} while (g <= 1);",
            "\t\t\tif (g == n) {",
            "\t\t\t\tdo {",
            "\t\t\t\t\tys = f(ys);",
            "\t\t\t\t\tg = std::__gcd(std::abs(x - ys), n);",
            "\t\t\t\t} while (g <= 1);",
            "\t\t\t}",
            "\t\t\tif (g != n) return g;",
            "\t\t}",
            "\t}",
            "",
            "\tstd::vector<long long> operator()(long long n) {",
            "\t\tstd::vector<long long> ret;",
            "\t\twhile (n > 1) {",
            "\t\t\tlong long f = find_factor(n);",
            "\t\t\tif (f < n) {",
            "\t\t\t\tauto tmp = operator()(f);",
            "\t\t\t\tret.insert(ret.end(), tmp.begin(), tmp.end());",
            "\t\t\t} else",
            "\t\t\t\tret.push_back(n);",
            "\t\t\tn /= f;",
            "\t\t}",
            "\t\tstd::sort(ret.begin(), ret.end());",
            "\t\treturn ret;",
            "\t}",
            "\tlong long euler_phi(long long n) {",
            "\t\tlong long ret = 1, last = -1;",
            "\t\tfor (auto p : this->operator()(n)) ret *= p - (last != p), last = p;",
            "\t\treturn ret;",
            "\t}",
            "} factorize;"
        ]
    },
    "timer": {
        "prefix": "timer",
        "body": [
            "struct Timer {",
            "\tTimer() { reset(); }",
            "",
            "\tvoid reset() { bgn = std::chrono::high_resolution_clock::now(); }",
            "",
            "\ttemplate <typename PeriodType = std::chrono::milliseconds>",
            "\tlong long elapsed() const {",
            "\t\tconst std::chrono::high_resolution_clock::time_point end = std::chrono::high_resolution_clock::now();",
            "\t\treturn std::chrono::duration_cast<PeriodType>(end - bgn).count();",
            "\t}",
            "",
            "\tvoid display_time_elapsed() { cerr   << \"[Time Elapsed = \" << elapsed() << \"ms]\" << endl; }",
            "",
            "   private:",
            "\tstd::chrono::high_resolution_clock::time_point bgn;",
            "};"
        ]
    },
    "atcoder_modint": {
        "prefix": "atcoder_modint",
        "body": [
            "",
            "namespace atcoder {",
            "",
            "\tnamespace internal {",
            "",
            "#ifndef _MSC_VER",
            "\t\ttemplate <class T>",
            "\t\tusing is_signed_int128 = typename std::conditional<std::is_same<T, __int128_t>::value || std::is_same<T, __int128>::value,",
            "\t\t\t\t\t\t\t\t\t\t\t\t\t\t   std::true_type, std::false_type>::type;",
            "",
            "\t\ttemplate <class T>",
            "\t\tusing is_unsigned_int128 =",
            "\t\t\ttypename std::conditional<std::is_same<T, __uint128_t>::value || std::is_same<T, unsigned __int128>::value,",
            "\t\t\t\t\t\t\t\t\t  std::true_type, std::false_type>::type;",
            "",
            "\t\ttemplate <class T>",
            "\t\tusing make_unsigned_int128 =",
            "\t\t\ttypename std::conditional<std::is_same<T, __int128_t>::value, __uint128_t, unsigned __int128>;",
            "",
            "\t\ttemplate <class T>",
            "\t\tusing is_integral =",
            "\t\t\ttypename std::conditional<std::is_integral<T>::value || is_signed_int128<T>::value || is_unsigned_int128<T>::value,",
            "\t\t\t\t\t\t\t\t\t  std::true_type, std::false_type>::type;",
            "",
            "\t\ttemplate <class T>",
            "\t\tusing is_signed_int =",
            "\t\t\ttypename std::conditional<(is_integral<T>::value && std::is_signed<T>::value) || is_signed_int128<T>::value,",
            "\t\t\t\t\t\t\t\t\t  std::true_type, std::false_type>::type;",
            "",
            "\t\ttemplate <class T>",
            "\t\tusing is_unsigned_int =",
            "\t\t\ttypename std::conditional<(is_integral<T>::value && std::is_unsigned<T>::value) || is_unsigned_int128<T>::value,",
            "\t\t\t\t\t\t\t\t\t  std::true_type, std::false_type>::type;",
            "",
            "\t\ttemplate <class T>",
            "\t\tusing to_unsigned = typename std::conditional<",
            "\t\t\tis_signed_int128<T>::value, make_unsigned_int128<T>,",
            "\t\t\ttypename std::conditional<std::is_signed<T>::value, std::make_unsigned<T>, std::common_type<T>>::type>::type;",
            "",
            "#else",
            "",
            "\t\ttemplate <class T>",
            "\t\tusing is_integral = typename std::is_integral<T>;",
            "",
            "\t\ttemplate <class T>",
            "\t\tusing is_signed_int =",
            "\t\t\ttypename std::conditional<is_integral<T>::value && std::is_signed<T>::value, std::true_type, std::false_type>::type;",
            "",
            "\t\ttemplate <class T>",
            "\t\tusing is_unsigned_int =",
            "\t\t\ttypename std::conditional<is_integral<T>::value && std::is_unsigned<T>::value, std::true_type, std::false_type>::type;",
            "",
            "\t\ttemplate <class T>",
            "\t\tusing to_unsigned = typename std::conditional<is_signed_int<T>::value, std::make_unsigned<T>, std::common_type<T>>::type;",
            "",
            "#endif",
            "",
            "\t\ttemplate <class T>",
            "\t\tusing is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;",
            "",
            "\t\ttemplate <class T>",
            "\t\tusing is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;",
            "",
            "\t\ttemplate <class T>",
            "\t\tusing to_unsigned_t = typename to_unsigned<T>::type;",
            "",
            "\t}  // namespace internal",
            "",
            "}  // namespace atcoder",
            "",
            "namespace atcoder {",
            "",
            "\tnamespace internal {",
            "\t\tconstexpr long long safe_mod(long long x, long long m) {",
            "\t\t\tx %= m;",
            "\t\t\tif (x < 0) x += m;",
            "\t\t\treturn x;",
            "\t\t}",
            "\t\tstruct barrett {",
            "\t\t\tunsigned int _m;",
            "\t\t\tunsigned long long im;",
            "\t\t\texplicit barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}",
            "\t\t\tunsigned int umod() const { return _m; }",
            "\t\t\tunsigned int mul(unsigned int a, unsigned int b) const {",
            "\t\t\t\tunsigned long long z = a;",
            "\t\t\t\tz *= b;",
            "#ifdef _MSC_VER",
            "\t\t\t\tunsigned long long x;",
            "\t\t\t\t_umul128(z, im, &x);",
            "#else",
            "\t\t\t\tunsigned long long x = (unsigned long long)(((unsigned __int128)(z)*im) >> 64);",
            "#endif",
            "\t\t\t\tunsigned long long y = x * _m;",
            "\t\t\t\treturn (unsigned int)(z - y + (z < y ? _m : 0));",
            "\t\t\t}",
            "\t\t};",
            "",
            "\t\tconstexpr long long pow_mod_constexpr(long long x, long long n, int m) {",
            "\t\t\tif (m == 1) return 0;",
            "\t\t\tunsigned int _m = (unsigned int)(m);",
            "\t\t\tunsigned long long r = 1;",
            "\t\t\tunsigned long long y = safe_mod(x, m);",
            "\t\t\twhile (n) {",
            "\t\t\t\tif (n & 1) r = (r * y) % _m;",
            "\t\t\t\ty = (y * y) % _m;",
            "\t\t\t\tn >>= 1;",
            "\t\t\t}",
            "\t\t\treturn r;",
            "\t\t}",
            "",
            "\t\tconstexpr bool is_prime_constexpr(int n) {",
            "\t\t\tif (n <= 1) return false;",
            "\t\t\tif (n == 2 || n == 7 || n == 61) return true;",
            "\t\t\tif (n % 2 == 0) return false;",
            "\t\t\tlong long d = n - 1;",
            "\t\t\twhile (d % 2 == 0) d /= 2;",
            "\t\t\tconstexpr long long bases[3] = {2, 7, 61};",
            "\t\t\tfor (long long a : bases) {",
            "\t\t\t\tlong long t = d;",
            "\t\t\t\tlong long y = pow_mod_constexpr(a, t, n);",
            "\t\t\t\twhile (t != n - 1 && y != 1 && y != n - 1) {",
            "\t\t\t\t\ty = y * y % n;",
            "\t\t\t\t\tt <<= 1;",
            "\t\t\t\t}",
            "\t\t\t\tif (y != n - 1 && t % 2 == 0) {",
            "\t\t\t\t\treturn false;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\treturn true;",
            "\t\t}",
            "\t\ttemplate <int n>",
            "\t\tconstexpr bool is_prime = is_prime_constexpr(n);",
            "\t\tconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {",
            "\t\t\ta = safe_mod(a, b);",
            "\t\t\tif (a == 0) return {b, 0};",
            "\t\t\tlong long s = b, t = a;",
            "\t\t\tlong long m0 = 0, m1 = 1;",
            "",
            "\t\t\twhile (t) {",
            "\t\t\t\tlong long u = s / t;",
            "\t\t\t\ts -= t * u;",
            "\t\t\t\tm0 -= m1 * u;",
            "\t\t\t\tauto tmp = s;",
            "\t\t\t\ts = t;",
            "\t\t\t\tt = tmp;",
            "\t\t\t\ttmp = m0;",
            "\t\t\t\tm0 = m1;",
            "\t\t\t\tm1 = tmp;",
            "\t\t\t}",
            "\t\t\tif (m0 < 0) m0 += b / s;",
            "\t\t\treturn {s, m0};",
            "\t\t}",
            "\t}  // namespace internal",
            "}  // namespace atcoder",
            "",
            "namespace atcoder {",
            "",
            "\tnamespace internal {",
            "",
            "\t\tstruct modint_base {};",
            "\t\tstruct static_modint_base : modint_base {};",
            "",
            "\t\ttemplate <class T>",
            "\t\tusing is_modint = std::is_base_of<modint_base, T>;",
            "\t\ttemplate <class T>",
            "\t\tusing is_modint_t = std::enable_if_t<is_modint<T>::value>;",
            "",
            "\t}  // namespace internal",
            "",
            "\ttemplate <int m, std::enable_if_t<(1 <= m)> * = nullptr>",
            "\tstruct static_modint : internal::static_modint_base {",
            "\t\tusing mint = static_modint;",
            "",
            "\t   public:",
            "\t\tstatic constexpr int mod() { return m; }",
            "\t\tstatic mint raw(int v) {",
            "\t\t\tmint x;",
            "\t\t\tx._v = v;",
            "\t\t\treturn x;",
            "\t\t}",
            "",
            "\t\tstatic_modint() : _v(0) {}",
            "\t\ttemplate <class T, internal::is_signed_int_t<T> * = nullptr>",
            "\t\tstatic_modint(T v) {",
            "\t\t\tlong long x = (long long)(v % (long long)(umod()));",
            "\t\t\tif (x < 0) x += umod();",
            "\t\t\t_v = (unsigned int)(x);",
            "\t\t}",
            "\t\ttemplate <class T, internal::is_unsigned_int_t<T> * = nullptr>",
            "\t\tstatic_modint(T v) {",
            "\t\t\t_v = (unsigned int)(v % umod());",
            "\t\t}",
            "",
            "\t\tunsigned int val() const { return _v; }",
            "",
            "\t\tmint &operator++() {",
            "\t\t\t_v++;",
            "\t\t\tif (_v == umod()) _v = 0;",
            "\t\t\treturn *this;",
            "\t\t}",
            "\t\tmint &operator--() {",
            "\t\t\tif (_v == 0) _v = umod();",
            "\t\t\t_v--;",
            "\t\t\treturn *this;",
            "\t\t}",
            "\t\tmint operator++(int) {",
            "\t\t\tmint result = *this;",
            "\t\t\t++*this;",
            "\t\t\treturn result;",
            "\t\t}",
            "\t\tmint operator--(int) {",
            "\t\t\tmint result = *this;",
            "\t\t\t--*this;",
            "\t\t\treturn result;",
            "\t\t}",
            "",
            "\t\tmint &operator+=(const mint &rhs) {",
            "\t\t\t_v += rhs._v;",
            "\t\t\tif (_v >= umod()) _v -= umod();",
            "\t\t\treturn *this;",
            "\t\t}",
            "\t\tmint &operator-=(const mint &rhs) {",
            "\t\t\t_v -= rhs._v;",
            "\t\t\tif (_v >= umod()) _v += umod();",
            "\t\t\treturn *this;",
            "\t\t}",
            "\t\tmint &operator*=(const mint &rhs) {",
            "\t\t\tunsigned long long z = _v;",
            "\t\t\tz *= rhs._v;",
            "\t\t\t_v = (unsigned int)(z % umod());",
            "\t\t\treturn *this;",
            "\t\t}",
            "\t\tmint &operator/=(const mint &rhs) { return *this = *this * rhs.inv(); }",
            "",
            "\t\tmint operator+() const { return *this; }",
            "\t\tmint operator-() const { return mint() - *this; }",
            "",
            "\t\tmint pow(long long n) const {",
            "\t\t\tassert(0 <= n);",
            "\t\t\tmint x = *this, r = 1;",
            "\t\t\twhile (n) {",
            "\t\t\t\tif (n & 1) r *= x;",
            "\t\t\t\tx *= x;",
            "\t\t\t\tn >>= 1;",
            "\t\t\t}",
            "\t\t\treturn r;",
            "\t\t}",
            "\t\tmint inv() const {",
            "\t\t\tif (prime) {",
            "\t\t\t\tassert(_v);",
            "\t\t\t\treturn pow(umod() - 2);",
            "\t\t\t} else {",
            "\t\t\t\tauto eg = internal::inv_gcd(_v, m);",
            "\t\t\t\tassert(eg.first == 1);",
            "\t\t\t\treturn eg.second;",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\tfriend mint operator+(const mint &lhs, const mint &rhs) { return mint(lhs) += rhs; }",
            "\t\tfriend mint operator-(const mint &lhs, const mint &rhs) { return mint(lhs) -= rhs; }",
            "\t\tfriend mint operator*(const mint &lhs, const mint &rhs) { return mint(lhs) *= rhs; }",
            "\t\tfriend mint operator/(const mint &lhs, const mint &rhs) { return mint(lhs) /= rhs; }",
            "\t\tfriend bool operator==(const mint &lhs, const mint &rhs) { return lhs._v == rhs._v; }",
            "\t\tfriend bool operator!=(const mint &lhs, const mint &rhs) { return lhs._v != rhs._v; }",
            "",
            "\t   private:",
            "\t\tunsigned int _v;",
            "\t\tstatic constexpr unsigned int umod() { return m; }",
            "\t\tstatic constexpr bool prime = internal::is_prime<m>;",
            "\t};",
            "",
            "\ttemplate <int id>",
            "\tstruct dynamic_modint : internal::modint_base {",
            "\t\tusing mint = dynamic_modint;",
            "",
            "\t   public:",
            "\t\tstatic int mod() { return (int)(bt.umod()); }",
            "",
            "\t\tstatic void set_mod(int m) {",
            "\t\t\tassert(1 <= m);",
            "\t\t\tbt = internal::barrett(m);",
            "\t\t}",
            "",
            "\t\tstatic mint raw(int v) {",
            "\t\t\tmint x;",
            "\t\t\tx._v = v;",
            "\t\t\treturn x;",
            "\t\t}",
            "",
            "\t\tdynamic_modint() : _v(0) {}",
            "",
            "\t\ttemplate <class T, internal::is_signed_int_t<T> * = nullptr>",
            "\t\tdynamic_modint(T v) {",
            "\t\t\tlong long x = (long long)(v % (long long)(mod()));",
            "\t\t\tif (x < 0) x += mod();",
            "\t\t\t_v = (unsigned int)(x);",
            "\t\t}",
            "",
            "\t\ttemplate <class T, internal::is_unsigned_int_t<T> * = nullptr>",
            "\t\tdynamic_modint(T v) {",
            "\t\t\t_v = (unsigned int)(v % mod());",
            "\t\t}",
            "",
            "\t\tunsigned int val() const { return _v; }",
            "",
            "\t\tmint &operator++() {",
            "\t\t\t_v++;",
            "\t\t\tif (_v == umod()) _v = 0;",
            "\t\t\treturn *this;",
            "\t\t}",
            "\t\tmint &operator--() {",
            "\t\t\tif (_v == 0) _v = umod();",
            "\t\t\t_v--;",
            "\t\t\treturn *this;",
            "\t\t}",
            "\t\tmint operator++(int) {",
            "\t\t\tmint result = *this;",
            "\t\t\t++*this;",
            "\t\t\treturn result;",
            "\t\t}",
            "\t\tmint operator--(int) {",
            "\t\t\tmint result = *this;",
            "\t\t\t--*this;",
            "\t\t\treturn result;",
            "\t\t}",
            "",
            "\t\tmint &operator+=(const mint &rhs) {",
            "\t\t\t_v += rhs._v;",
            "\t\t\tif (_v >= umod()) _v -= umod();",
            "\t\t\treturn *this;",
            "\t\t}",
            "\t\tmint &operator-=(const mint &rhs) {",
            "\t\t\t_v += mod() - rhs._v;",
            "\t\t\tif (_v >= umod()) _v -= umod();",
            "\t\t\treturn *this;",
            "\t\t}",
            "\t\tmint &operator*=(const mint &rhs) {",
            "\t\t\t_v = bt.mul(_v, rhs._v);",
            "\t\t\treturn *this;",
            "\t\t}",
            "\t\tmint &operator/=(const mint &rhs) { return *this = *this * rhs.inv(); }",
            "",
            "\t\tmint operator+() const { return *this; }",
            "\t\tmint operator-() const { return mint() - *this; }",
            "",
            "\t\tmint pow(long long n) const {",
            "\t\t\tassert(0 <= n);",
            "\t\t\tmint x = *this, r = 1;",
            "\t\t\twhile (n) {",
            "\t\t\t\tif (n & 1) r *= x;",
            "\t\t\t\tx *= x;",
            "\t\t\t\tn >>= 1;",
            "\t\t\t}",
            "\t\t\treturn r;",
            "\t\t}",
            "\t\tmint inv() const {",
            "\t\t\tauto eg = internal::inv_gcd(_v, mod());",
            "\t\t\tassert(eg.first == 1);",
            "\t\t\treturn eg.second;",
            "\t\t}",
            "",
            "\t\tfriend mint operator+(const mint &lhs, const mint &rhs) { return mint(lhs) += rhs; }",
            "\t\tfriend mint operator-(const mint &lhs, const mint &rhs) { return mint(lhs) -= rhs; }",
            "\t\tfriend mint operator*(const mint &lhs, const mint &rhs) { return mint(lhs) *= rhs; }",
            "\t\tfriend mint operator/(const mint &lhs, const mint &rhs) { return mint(lhs) /= rhs; }",
            "\t\tfriend bool operator==(const mint &lhs, const mint &rhs) { return lhs._v == rhs._v; }",
            "\t\tfriend bool operator!=(const mint &lhs, const mint &rhs) { return lhs._v != rhs._v; }",
            "",
            "\t   private:",
            "\t\tunsigned int _v;",
            "\t\tstatic internal::barrett bt;",
            "\t\tstatic unsigned int umod() { return bt.umod(); }",
            "\t};",
            "\ttemplate <int id>",
            "\tinternal::barrett dynamic_modint<id>::bt(998244353);",
            "",
            "\tusing modint998244353 = static_modint<998244353>;",
            "\tusing modint1000000007 = static_modint<1000000007>;",
            "\tusing modint = dynamic_modint<-1>;",
            "",
            "\tnamespace internal {",
            "",
            "\t\ttemplate <class T>",
            "\t\tusing is_static_modint = std::is_base_of<internal::static_modint_base, T>;",
            "",
            "\t\ttemplate <class T>",
            "\t\tusing is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;",
            "",
            "\t\ttemplate <class>",
            "\t\tstruct is_dynamic_modint : public std::false_type {};",
            "",
            "\t\ttemplate <int id>",
            "\t\tstruct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};",
            "",
            "\t\ttemplate <class T>",
            "\t\tusing is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;",
            "",
            "\t}  // namespace internal",
            "",
            "}  // namespace atcoder",
            "",
            "using namespace atcoder;",
            "// using mint = static_modint<998244353>;",
            "using mint = static_modint<1000000007>;$0",
            ""
        ]
    },
    "dynamic_bitset": {
        "prefix": "dynamic_bitset",
        "body": [
            "",
            "struct DynamicBitSet {",
            "   private:",
            "\tusing block = unsigned long long;",
            "\tstatic constexpr std::size_t block_size = std::numeric_limits<block>::digits;",
            "\tstatic constexpr std::size_t log_block_size = __builtin_ctz(block_size);",
            "",
            "\tstruct bitref {",
            "\t\tblock& b;",
            "\t\tstd::size_t i;",
            "\t\toperator bool() const { return (b >> i) & 1; }",
            "\t\tbool test() const { return (b >> i) & 1; }",
            "\t\tvoid set() { b |= block(1) << i; }",
            "\t\tvoid reset() { b &= ~(block(1) << i); }",
            "\t\tvoid flip() { b ^= block(1) << i; }",
            "\t\tbitref& operator&=(bool val) {",
            "\t\t\tb &= block(val) << i;",
            "\t\t\treturn *this;",
            "\t\t}",
            "\t\tbitref& operator|=(bool val) {",
            "\t\t\tb |= block(val) << i;",
            "\t\t\treturn *this;",
            "\t\t}",
            "\t\tbitref& operator^=(bool val) {",
            "\t\t\tb ^= block(val) << i;",
            "\t\t\treturn *this;",
            "\t\t}",
            "\t\tbitref& operator=(bool val) {",
            "\t\t\tval ? set() : reset();",
            "\t\t\treturn *this;",
            "\t\t}",
            "\t\tbitref& operator=(const bitref& v) { return (*this) = bool(v); }",
            "\t};",
            "",
            "\tstd::size_t n;",
            "\tstd::vector<block> blocks;",
            "",
            "   public:",
            "\tDynamicBitSet(std::size_t n = 0, bool fill_value = false)",
            "\t\t: n(n), blocks((n + block_size - 1) >> log_block_size, fill_value ? ~block(0) : 0) {}",
            "",
            "\tbool empty() const { return n == 0; }",
            "\tint size() const { return n; }",
            "",
            "\tvoid resize(std::size_t new_size, bool fill_value = false) {",
            "\t\tstd::size_t new_block_num = (new_size + block_size - 1) >> log_block_size;",
            "\t\tif (new_block_num < block_num()) {",
            "\t\t\tn = new_size;",
            "\t\t\treturn blocks.resize(new_block_num);",
            "\t\t}",
            "\t\tblocks.resize(new_block_num);",
            "\t\tstd::size_t old_size = std::exchange(n, new_size);",
            "\t\tif (old_size <= new_size) range_update(old_size, new_size, fill_value);",
            "\t}",
            "\tvoid push_back(bool val) {",
            "\t\tif (n & (block_size - 1)) {",
            "\t\t\t(*this)[n] = val;",
            "\t\t} else {",
            "\t\t\tblocks.push_back(val);",
            "\t\t}",
            "\t\t++n;",
            "\t}",
            "\tvoid pop_back() {",
            "\t\tif ((n & (block_size - 1)) == 1) blocks.pop_back();",
            "\t\t--n;",
            "\t}",
            "",
            "\tfriend bool operator==(const DynamicBitSet& x, const DynamicBitSet& y) {",
            "\t\tif (x.n != y.n) return false;",
            "\t\tif (x.empty()) return true;",
            "\t\tfor (std::size_t i = 0; i < x.block_num() - 1; ++i) {",
            "\t\t\tif (x.blocks[i] != y.blocks[i]) return false;",
            "\t\t}",
            "\t\tconst std::size_t num = x.n - ((x.block_num() - 1) << log_block_size);",
            "\t\treturn get_lower_bits(x.blocks.back(), num) == get_lower_bits(y.blocks.back(), num);",
            "\t}",
            "\tfriend bool operator!=(const DynamicBitSet& x, const DynamicBitSet& y) { return not(x == y); }",
            "\tfriend bool operator<(const DynamicBitSet& x, const DynamicBitSet& y) {",
            "\t\tassert(x.n == y.n);",
            "\t\tif (x.empty()) return false;",
            "\t\tstd::size_t num = x.n - ((x.block_num() - 1) << log_block_size);",
            "\t\tblock tx = get_lower_bits(x.blocks.back(), num);",
            "\t\tblock ty = get_lower_bits(y.blocks.back(), num);",
            "\t\tif (tx != ty) return tx < ty;",
            "\t\tfor (std::size_t i = x.block_num() - 1; i-- > 0;) {",
            "\t\t\tif (x.blocks[i] != y.blocks[i]) return x.blocks[i] < y.blocks[i];",
            "\t\t}",
            "\t\treturn false;",
            "\t}",
            "\tfriend bool operator<=(const DynamicBitSet& x, const DynamicBitSet& y) {",
            "\t\tassert(x.n == y.n);",
            "\t\tif (x.empty()) return true;",
            "\t\tstd::size_t num = x.n - ((x.block_num() - 1) << log_block_size);",
            "\t\tblock tx = get_lower_bits(x.blocks.back(), num);",
            "\t\tblock ty = get_lower_bits(y.blocks.back(), num);",
            "\t\tif (tx != ty) return tx < ty;",
            "\t\tfor (std::size_t i = x.block_num() - 1; i-- > 0;) {",
            "\t\t\tif (x.blocks[i] != y.blocks[i]) return x.blocks[i] < y.blocks[i];",
            "\t\t}",
            "\t\treturn true;",
            "\t}",
            "\tfriend bool operator>(const DynamicBitSet& x, const DynamicBitSet& y) { return not(x <= y); }",
            "\tfriend bool operator>=(const DynamicBitSet& x, const DynamicBitSet& y) { return not(x < y); }",
            "",
            "\toperator bool() const { return any(); }",
            "",
            "\tfriend DynamicBitSet& operator&=(DynamicBitSet& x, const DynamicBitSet& y) {",
            "\t\tassert(x.n == y.n);",
            "\t\tfor (std::size_t i = 0; i < y.block_num(); ++i) x.blocks[i] &= y.blocks[i];",
            "\t\treturn x;",
            "\t}",
            "\tfriend DynamicBitSet& operator|=(DynamicBitSet& x, const DynamicBitSet& y) {",
            "\t\tassert(x.n == y.n);",
            "\t\tfor (std::size_t i = 0; i < y.block_num(); ++i) x.blocks[i] |= y.blocks[i];",
            "\t\treturn x;",
            "\t}",
            "\tfriend DynamicBitSet& operator^=(DynamicBitSet& x, const DynamicBitSet& y) {",
            "\t\tassert(x.n == y.n);",
            "\t\tfor (std::size_t i = 0; i < y.block_num(); ++i) x.blocks[i] ^= y.blocks[i];",
            "\t\treturn x;",
            "\t}",
            "\tfriend DynamicBitSet operator&(DynamicBitSet x, const DynamicBitSet& y) {",
            "\t\tx &= y;",
            "\t\treturn x;",
            "\t}",
            "\tfriend DynamicBitSet operator|(DynamicBitSet x, const DynamicBitSet& y) {",
            "\t\tx |= y;",
            "\t\treturn x;",
            "\t}",
            "\tfriend DynamicBitSet operator^(DynamicBitSet x, const DynamicBitSet& y) {",
            "\t\tx ^= y;",
            "\t\treturn x;",
            "\t}",
            "",
            "\tfriend DynamicBitSet& operator<<=(DynamicBitSet& x, std::size_t shamt) { return x = x << shamt; }",
            "\tfriend DynamicBitSet& operator>>=(DynamicBitSet& x, std::size_t shamt) { return x = x >> shamt; }",
            "\tfriend DynamicBitSet operator<<(const DynamicBitSet& x, std::size_t shamt) {",
            "\t\tif (shamt >= x.n) return DynamicBitSet(x.size());",
            "\t\tDynamicBitSet res(x.size());",
            "\t\tstd::size_t block_shamt = shamt >> log_block_size;",
            "\t\tstd::size_t bit_shamt = shamt & (block_size - 1);",
            "\t\tfor (std::size_t i = 0; i + block_shamt < res.block_num(); ++i) {",
            "\t\t\tif (bit_shamt == 0) {",
            "\t\t\t\tres.blocks[i + block_shamt] = x.blocks[i];",
            "\t\t\t} else {",
            "\t\t\t\tres.blocks[i + block_shamt] |= x.blocks[i] << bit_shamt;",
            "\t\t\t\tif (i + block_shamt + 1 != res.block_num()) {",
            "\t\t\t\t\tres.blocks[i + block_shamt + 1] |= x.blocks[i] >> (block_size - bit_shamt);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\tfriend DynamicBitSet operator>>(const DynamicBitSet& x, std::size_t shamt) {",
            "\t\tif (shamt >= x.n) return DynamicBitSet(x.size());",
            "\t\tDynamicBitSet res(x.size());",
            "\t\tstd::size_t block_shamt = shamt >> log_block_size;",
            "\t\tstd::size_t bit_shamt = shamt & (block_size - 1);",
            "\t\tfor (std::size_t i = 0; i + block_shamt < x.block_num(); ++i) {",
            "\t\t\tif (bit_shamt == 0) {",
            "\t\t\t\tres.blocks[i] = x.blocks[i + block_shamt];",
            "\t\t\t} else {",
            "\t\t\t\tres.blocks[i] |= x.blocks[i + block_shamt] >> bit_shamt;",
            "\t\t\t\tif (i + block_shamt + 1 != x.block_num()) {",
            "\t\t\t\t\tres.blocks[i] |= x.blocks[i + block_shamt + 1] << (block_size - bit_shamt);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\tres.range_reset(x.n - shamt, x.n);",
            "\t\treturn res;",
            "\t}",
            "",
            "\tDynamicBitSet operator~() const {",
            "\t\tDynamicBitSet neg(n);",
            "\t\tfor (std::size_t i = 0; i < block_num(); ++i) neg.blocks[i] = ~blocks[i];",
            "\t\treturn neg;",
            "\t}",
            "",
            "\tbool operator[](std::size_t i) const { return (blocks[block_index(i)] >> bit_index(i)) & 1; }",
            "\tbitref operator[](std::size_t i) { return {blocks[block_index(i)], bit_index(i)}; }",
            "",
            "\tvoid range_set(std::size_t l, std::size_t r) {",
            "\t\tassert(l <= r and r <= n);",
            "\t\tif (l == r) return;",
            "\t\tstd::size_t lb = block_index(l), rb = block_index(r - 1);",
            "\t\tstd::size_t li = bit_index(l), ri = bit_index(r);",
            "\t\tif (ri == 0) ri = block_size;",
            "\t\tif (lb == rb) {",
            "\t\t\tblocks[lb] |= mask_range_bits(~block(0), li, ri);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tblocks[lb] |= mask_upper_bits(~block(0), block_size - li);",
            "\t\tblocks[rb] |= mask_lower_bits(~block(0), ri);",
            "\t\tfor (std::size_t i = lb + 1; i < rb; ++i) blocks[i] = ~block(0);",
            "\t}",
            "\tvoid range_reset(std::size_t l, std::size_t r) {",
            "\t\tassert(l <= r and r <= n);",
            "\t\tif (l == r) return;",
            "\t\tstd::size_t lb = block_index(l), rb = block_index(r - 1);",
            "\t\tstd::size_t li = bit_index(l), ri = bit_index(r);",
            "\t\tif (ri == 0) ri = block_size;",
            "\t\tif (lb == rb) {",
            "\t\t\tblocks[lb] &= ~mask_range_bits(~block(0), li, ri);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tblocks[lb] &= ~mask_upper_bits(~block(0), block_size - li);",
            "\t\tblocks[rb] &= ~mask_lower_bits(~block(0), ri);",
            "\t\tfor (std::size_t i = lb + 1; i < rb; ++i) blocks[i] = block(0);",
            "\t}",
            "\tvoid range_flip(std::size_t l, std::size_t r) {",
            "\t\tassert(l <= r and r <= n);",
            "\t\tif (l == r) return;",
            "\t\tstd::size_t lb = block_index(l), rb = block_index(r - 1);",
            "\t\tstd::size_t li = bit_index(l), ri = bit_index(r);",
            "\t\tif (ri == 0) ri = block_size;",
            "\t\tif (lb == rb) {",
            "\t\t\tblocks[lb] ^= mask_range_bits(~block(0), li, ri);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tblocks[lb] ^= mask_upper_bits(~block(0), block_size - li);",
            "\t\tblocks[rb] ^= mask_lower_bits(~block(0), ri);",
            "\t\tfor (std::size_t i = lb + 1; i < rb; ++i) blocks[i] ^= ~block(0);",
            "\t}",
            "\tvoid range_update(std::size_t l, std::size_t r, bool val) { val ? range_set(l, r) : range_reset(l, r); }",
            "\tint range_count(std::size_t l, std::size_t r) const {",
            "\t\tassert(l <= r and r <= n);",
            "\t\tif (l == r) return 0;",
            "\t\tstd::size_t lb = block_index(l), rb = block_index(r - 1);",
            "\t\tstd::size_t li = bit_index(l), ri = bit_index(r);",
            "\t\tif (ri == 0) ri = block_size;",
            "",
            "\t\tif (lb == rb) {",
            "\t\t\treturn __builtin_popcountll(blocks[lb] & mask_range_bits(~block(0), li, ri));",
            "\t\t}",
            "\t\tint res = 0;",
            "\t\tres += __builtin_popcountll(blocks[lb] & mask_upper_bits(~block(0), block_size - li));",
            "\t\tres += __builtin_popcountll(blocks[rb] & mask_lower_bits(~block(0), ri));",
            "\t\tfor (std::size_t i = lb + 1; i < rb; ++i) res += __builtin_popcountll(blocks[i]);",
            "\t\treturn res;",
            "\t}",
            "",
            "\tvoid set() {",
            "\t\tfor (block& b : blocks) b = ~block(0);",
            "\t}",
            "\tvoid reset() {",
            "\t\tfor (block& b : blocks) b = 0;",
            "\t}",
            "\tbool all() const {",
            "\t\tif (empty()) return true;",
            "\t\tfor (std::size_t i = 0; i < block_num() - 1; ++i) {",
            "\t\t\tif (blocks[i] != ~block(0)) return false;",
            "\t\t}",
            "\t\tconst std::size_t num = n - ((block_num() - 1) << log_block_size);",
            "\t\tassert(num);",
            "\t\tconst block upper = ((block(1) << (block_size - num)) - 1) << num;",
            "\t\treturn (upper | blocks.back()) == ~block(0);",
            "\t}",
            "\tbool none() const {",
            "\t\tif (empty()) return true;",
            "\t\tfor (std::size_t i = 0; i < block_num() - 1; ++i) {",
            "\t\t\tif (blocks[i] != 0) return false;",
            "\t\t}",
            "\t\tconst std::size_t num = n - ((block_num() - 1) << log_block_size);",
            "\t\treturn get_lower_bits(blocks.back(), num) == 0;",
            "\t}",
            "\tbool any() const { return not none(); }",
            "\tint count() const {",
            "\t\tif (empty()) return 0;",
            "\t\tint res = 0;",
            "\t\tfor (std::size_t i = 0; i < block_num() - 1; ++i) {",
            "\t\t\tres += __builtin_popcountll(blocks[i]);",
            "\t\t}",
            "\t\tconst std::size_t num = n - ((block_num() - 1) << log_block_size);",
            "\t\treturn res + __builtin_popcountll(get_lower_bits(blocks.back(), num));",
            "\t}",
            "",
            "\t// Returns the position of first set bit. If there is no such positions, then returns size().",
            "\tint find_first() const {",
            "\t\tif (empty()) return size();",
            "\t\tfor (std::size_t i = 0; i < block_num(); ++i) {",
            "\t\t\tif (blocks[i] != 0) return std::min(n, __builtin_ctzll(blocks[i]) | (i << log_block_size));",
            "\t\t}",
            "\t\treturn n;",
            "\t}",
            "\t// Returns the position of first set bit after the given position (exclusive). If there is no such positions, then returns",
            "\t// size().",
            "\tint find_next(std::size_t pos) const {",
            "\t\tstd::size_t i = block_index(++pos);",
            "\t\tif (i >= blocks.size()) return n;",
            "\t\tblock upper = mask_upper_bits(blocks[i], block_size - bit_index(pos));",
            "\t\tif (upper != 0) return std::min(n, __builtin_ctzll(upper) | (i << log_block_size));",
            "\t\twhile (++i < block_num()) {",
            "\t\t\tif (blocks[i] != 0) return std::min(n, __builtin_ctzll(blocks[i]) | (i << log_block_size));",
            "\t\t}",
            "\t\treturn n;",
            "\t}",
            "",
            "\tbool has_intersection(const DynamicBitSet& y) const {",
            "\t\tif (n > y.n) return y.has_intersection(*this);",
            "\t\tif (empty()) return false;",
            "\t\tfor (std::size_t i = 0; i < block_num() - 1; ++i) {",
            "\t\t\tif (blocks[i] & y.blocks[i]) return true;",
            "\t\t}",
            "\t\tconst std::size_t num = n - ((block_num() - 1) << log_block_size);",
            "\t\treturn get_lower_bits(blocks.back(), num) & y.blocks[block_num() - 1];",
            "\t}",
            "\tbool is_disjoint(const DynamicBitSet& y) const { return not has_intersection(y); }",
            "",
            "   private:",
            "\tstatic constexpr std::size_t block_index(std::size_t i) { return i >> log_block_size; }",
            "\tstatic constexpr std::size_t bit_index(std::size_t i) { return i & (block_size - 1); }",
            "\tstatic constexpr block get_lower_bits(block b, std::size_t num) {",
            "\t\treturn num ? (b << (block_size - num) >> (block_size - num)) : block(0);",
            "\t}",
            "\tstatic constexpr block get_upper_bits(block b, std::size_t num) { return num ? (b >> (block_size - num)) : block(0); }",
            "\tstatic constexpr block get_range_bits(block b, std::size_t l, std::size_t r) {",
            "\t\treturn l < r ? b << (block_size - r) >> (block_size - r + l) : block(0);",
            "\t}",
            "\tstatic constexpr block mask_lower_bits(block b, std::size_t num) { return get_lower_bits(b, num); }",
            "\tstatic constexpr block mask_upper_bits(block b, std::size_t num) {",
            "\t\treturn num ? (b >> (block_size - num) << (block_size - num)) : block(0);",
            "\t}",
            "\tstatic constexpr block mask_range_bits(block b, std::size_t l, std::size_t r) {",
            "\t\treturn l < r ? b << (block_size - r) >> (block_size - r + l) << l : block(0);",
            "\t}",
            "",
            "\tstd::size_t block_num() const { return blocks.size(); }",
            "};"
        ]
    },
    "inc__debug_prps_file": {
        "prefix": "inc__debug__prps_file",
        "body": [
            "#if defined(LOCAL)",
            "#include \"__debug.h\"",
            "#else",
            "#define clg(...)",
            "#endif"
        ]
    },
    "fast_sqrt_and_cbrt": {
        "prefix": "fast_sqrt_and_cbrt",
        "body": [
            "unsigned long long fast_sqrt(unsigned long long n) {",
            "\tunsigned long long c, g;",
            "",
            "\tc = g = 0x80000000;",
            "\tfor (;;) {",
            "\t\tif ((g * g) > n)",
            "\t\t\tg ^= c;",
            "\t\tc >>= 1;",
            "\t\tif (!c)",
            "\t\t\treturn g;",
            "\t\tg |= c;",
            "\t}",
            "}",
            "",
            "unsigned long long fast_cbrt(unsigned long long n) {",
            "\tint r = 63;",
            "\tunsigned long long x, res = 0;",
            "",
            "\tfor (; r >= 0; r -= 3) {",
            "\t\tres <<= 1;",
            "\t\tx = (res * (res + 1) * 3) + 1;",
            "\t\tif ((n >> r) >= x) {",
            "\t\t\tres++;",
            "\t\t\tn -= (x << r);",
            "\t\t}",
            "\t}",
            "",
            "\treturn res;",
            "}",
            ""
        ]
    },
    "__debug_prps_file": {
        "prefix": "__debug__prps_file",
        "body": [
            "#define Writer_out cerr",
            "",
            "inline namespace debug_print {",
            "#define SFINAE(x, ...)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   \\",
            "\ttemplate <class, class = void> struct x : std::false_type {};\t\t\t\t\t\t\t\t\t\t\t\\",
            "\ttemplate <class T> struct x<T, std::void_t<__VA_ARGS__>> : std::true_type {}",
            "",
            "SFINAE(DefaultI, decltype(std::cin >> std::declval<T &>()));",
            "SFINAE(DefaultO, decltype(std::cout << std::declval<T &>()));",
            "SFINAE(IsTuple, typename std::tuple_size<T>::type);",
            "SFINAE(Iterable, decltype(std::begin(std::declval<T>())));",
            "",
            "template <auto &os, bool debug, bool print_nd> struct Printer {",
            "\tstring comma() const { return debug ? \",\" : \"\"; }",
            "\ttemplate <class T> constexpr char Space(const T &) const {",
            "\t\treturn print_nd && (Iterable<T>::value or IsTuple<T>::value) ? '\\n' : ' ';",
            "\t}",
            "\ttemplate <class T> void Impl(T const &t) const {",
            "\t\tif constexpr (DefaultO<T>::value)",
            "\t\t\tos << t;",
            "\t\telse if constexpr (Iterable<T>::value) {",
            "\t\t\tif (debug)",
            "\t\t\t\tos << '{';",
            "\t\t\tint i = 0;",
            "\t\t\tfor (auto &&x : t)",
            "\t\t\t\t((i++) ? (os << comma() << Space(x), Impl(x)) : Impl(x));",
            "\t\t\tif (debug)",
            "\t\t\t\tos << '}';",
            "\t\t} else if constexpr (IsTuple<T>::value) {",
            "\t\t\tif (debug)",
            "\t\t\t\tos << '(';",
            "\t\t\tstd::apply(",
            "\t\t\t\t[this](auto const &...args) {",
            "\t\t\t\t\tint i = 0;",
            "\t\t\t\t\t(((i++) ? (os << comma() << \" \", Impl(args)) : Impl(args)), ...);",
            "\t\t\t\t},",
            "\t\t\t\tt);",
            "\t\t\tif (debug)",
            "\t\t\t\tos << ')';",
            "\t\t} else",
            "\t\t\tstatic_assert(IsTuple<T>::value, \"No matching type for print\");",
            "\t}",
            "\ttemplate <class T> void ImplWrapper(T const &t) const { Impl(t); }",
            "\ttemplate <class... Ts> void print(Ts const &...ts) const { ((Impl(ts)), ...); }",
            "\ttemplate <class F, class... Ts>",
            "\tvoid print_with_sep(const std::string &sep, F const &f, Ts const &...ts) const {",
            "\t\tImplWrapper(f), ((os << sep, ImplWrapper(ts)), ...), os << '\\n';",
            "\t}",
            "\tvoid print_with_sep(const std::string &) const { os << '\\n'; }",
            "};",
            "",
            "} // namespace debug_print",
            "",
            "template <typename... Args> void printerr(Args... args) {",
            "\tPrinter<Writer_out, true, false>{}.print_with_sep(\" | \", args...);",
            "}",
            "template <typename... Args> void printerrn(Args... args) {",
            "\tPrinter<Writer_out, true, true>{}.print_with_sep(\" | \", args...);",
            "}",
            "",
            "void err_prefix(string func, int line, string args) {",
            "\tWriter_out << func << \":\" << line << \": \"",
            "\t\t\t   << \"[\" << args << \"] = \";",
            "}",
            "#define clg(args...) err_prefix(__FUNCTION__, __LINE__, #args), printerr(args)"
        ]
    },
    "debug": {
        "prefix": "debug",
        "body": [
            "#define writer_out cerr",
            "string to_string(char c) { return \"'\" + string(1, c) + \"'\"; }",
            "",
            "string to_string(const string &s) { return '\"' + s + '\"'; }",
            "",
            "string to_string(bool b) { return (b ? \"true\" : \"false\"); }",
            "",
            "std::string to_string(const char *c) { return string(c); }",
            "",
            "inline auto digit_to_char(int digit) { return static_cast<char>(digit > 9 ? 'a' + digit - 10 : '0' + digit); }",
            "",
            "inline auto to_string(__int128_t num, int base = 10) {",
            "\tconst auto neg = num < 0;",
            "\tstd::string str;",
            "\tif (neg)",
            "\t\tnum = -num;",
            "\tdo",
            "\t\tstr += digit_to_char(num % base), num /= base;",
            "\twhile (num > 0);",
            "\tif (neg)",
            "\t\tstr += '-';",
            "\tstd::reverse(str.begin(), str.end());",
            "\treturn str;",
            "}",
            "",
            "inline auto to_string(__uint128_t num, int base = 10) {",
            "\tstd::string str;",
            "\tdo",
            "\t\tstr += digit_to_char(num % base), num /= base;",
            "\twhile (num > 0);",
            "\tstd::reverse(str.begin(), str.end());",
            "\treturn str;",
            "}",
            "",
            "template <typename T> string to_string(queue<T> q) {",
            "\tbool first = true;",
            "\tstring res = \"{\";",
            "\twhile (!q.empty()) {",
            "\t\tif (!first) {",
            "\t\t\tres += \", \";",
            "\t\t}",
            "\t\tfirst = false;",
            "\t\tres += to_string(q.front());",
            "\t\tq.pop();",
            "\t}",
            "\tres += \"}\";",
            "\treturn res;",
            "}",
            "",
            "template <typename T> string to_string(stack<T> st) {",
            "\tbool first = true;",
            "\tstring res = \"{\";",
            "\twhile (!st.empty()) {",
            "\t\tif (!first) {",
            "\t\t\tres += \", \";",
            "\t\t}",
            "\t\tfirst = false;",
            "\t\tres += to_string(st.top());",
            "\t\tst.pop();",
            "\t}",
            "\tres += \"}\";",
            "\treturn res;",
            "}",
            "",
            "template <typename T, typename Sequence = vector<T>, typename Compare = less<T>>",
            "string to_string(priority_queue<T, Sequence, Compare> pq) {",
            "\tbool first = true;",
            "\tstring res = \"{\";",
            "\twhile (!pq.empty()) {",
            "\t\tif (!first) {",
            "\t\t\tres += \", \";",
            "\t\t}",
            "\t\tfirst = false;",
            "\t\tres += to_string(pq.top());",
            "\t\tpq.pop();",
            "\t}",
            "\tres += \"}\";",
            "\treturn res;",
            "}",
            "",
            "string to_string(const vector<bool> &v) {",
            "\tbool first = true;",
            "\tstring res = \"{\";",
            "\tfor (int i = 0; i < (int)v.size(); i++) {",
            "\t\tif (!first) {",
            "\t\t\tres += \", \";",
            "\t\t}",
            "\t\tfirst = false;",
            "\t\tres += to_string(v[i]);",
            "\t}",
            "\tres += \"}\";",
            "\treturn res;",
            "}",
            "",
            "template <typename A, typename B> string to_string(const pair<A, B> &p) {",
            "\treturn \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";",
            "}",
            "",
            "template <typename A, typename B, typename C> string to_string(const tuple<A, B, C> &p) {",
            "\treturn \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";",
            "}",
            "",
            "template <typename A, typename B, typename C, typename D> string to_string(const tuple<A, B, C, D> &p) {",
            "\treturn \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" +",
            "\t\t   to_string(get<3>(p)) + \")\";",
            "}",
            "",
            "template <size_t N> string to_string(const bitset<N> &v) {",
            "\tstring res = v.to_string();",
            "\treturn res;",
            "}",
            "",
            "template <typename A> string to_string(const A &v) {",
            "\tbool first = true;",
            "\tstring res = \"{\";",
            "\tfor (auto &x : v) {",
            "\t\tif (!first) {",
            "\t\t\tres += \", \";",
            "\t\t}",
            "\t\tfirst = false;",
            "\t\tres += to_string(x);",
            "\t}",
            "\tres += \"}\";",
            "\treturn res;",
            "}",
            "",
            "void debug_out() { writer_out << \"\\n\"; }",
            "template <typename Head, typename... Tail> void debug_out(const Head H, const Tail &...T) {",
            "\twriter_out << to_string(H);",
            "\tif (sizeof...(T))",
            "\t\twriter_out << \"] [\";",
            "\telse",
            "\t\twriter_out << \"]\";",
            "\tdebug_out(T...);",
            "}",
            "",
            "void err_prefix(string func, int line) {",
            "\twriter_out << \"\\033[0;31m\\u001b[1mDEBUG\\033[0m: \"",
            "\t\t\t   << \"\\u001b[34m\" << func << \"\\033[0m\"",
            "\t\t\t   << \":\"",
            "\t\t\t   << \"\\u001b[34m\" << line << \"\\033[0m: \";",
            "}",
            "#ifdef CDEBUG",
            "#define clg(...)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\",
            "\terr_prefix(__FUNCTION__, __LINE__), writer_out << \"[\" << #__VA_ARGS__ << \"] = [\", debug_out(__VA_ARGS__)",
            "#else",
            "#define clg(...)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\",
            "\twriter_out << __func__ << \":\" << __LINE__ << \": \" << \"[\" << #__VA_ARGS__ << \"] = [\",\t\t\t\t\t \\",
            "\t\tdebug_out(__VA_ARGS__)",
            "#endif"
        ]
    },
    "_debug": {
        "prefix": "_debug",
        "body": [
            "#define writer_out cerr",
            "",
            "namespace __DEBUG_UTIL__ {",
            "inline auto digit_to_char(int digit) { return static_cast<char>(digit > 9 ? 'a' + digit - 10 : '0' + digit); }",
            "",
            "inline auto to_string(__int128_t num, int base = 10) {",
            "\tconst auto neg = num < 0;",
            "\tstd::string str;",
            "\tif (neg)",
            "\t\tnum = -num;",
            "\tdo",
            "\t\tstr += digit_to_char(num % base), num /= base;",
            "\twhile (num > 0);",
            "\tif (neg)",
            "\t\tstr += '-';",
            "\tstd::reverse(str.begin(), str.end());",
            "\treturn str;",
            "}",
            "",
            "inline auto to_string(__uint128_t num, int base = 10) {",
            "\tstd::string str;",
            "\tdo",
            "\t\tstr += digit_to_char(num % base), num /= base;",
            "\twhile (num > 0);",
            "\tstd::reverse(str.begin(), str.end());",
            "\treturn str;",
            "}",
            "/* Primitive Datatypes Print */",
            "void print(const char *x) { writer_out << x; }",
            "void print(bool x) { writer_out << (x ? \"True\" : \"False\"); }",
            "void print(char x) { writer_out << '\\'' << x << '\\''; }",
            "void print(signed short int x) { writer_out << x; }",
            "void print(unsigned short int x) { writer_out << x; }",
            "void print(signed int x) { writer_out << x; }",
            "void print(unsigned int x) { writer_out << x; }",
            "void print(signed long int x) { writer_out << x; }",
            "void print(unsigned long int x) { writer_out << x; }",
            "void print(signed long long int x) { writer_out << x; }",
            "void print(unsigned long long int x) { writer_out << x; }",
            "void print(float x) { writer_out << x; }",
            "void print(double x) { writer_out << x; }",
            "void print(long double x) { writer_out << x; }",
            "void print(string x) { writer_out << '\\\"' << x << '\\\"'; }",
            "template <size_t N> void print(bitset<N> x) { writer_out << x; }",
            "void print(vector<bool> v) { /* Overloaded this because stl optimizes",
            "\t\t\t\t\t\t\t\tvector<bool> by using _Bit_reference instead of",
            "\t\t\t\t\t\t\t\tbool to conserve space. */",
            "\tint f = 0;",
            "\twriter_out << '{';",
            "\tfor (auto &&i : v)",
            "\t\twriter_out << (f++ ? \",\" : \"\") << (i ? \"T\" : \"F\");",
            "\twriter_out << \"}\";",
            "}",
            "/* Templates Declarations to support nested datatypes */",
            "template <typename T> void print(T &&x);",
            "template <typename T> void print(vector<vector<T>> mat);",
            "template <typename T, size_t N, size_t M> void print(T (&mat)[N][M]);",
            "template <typename F, typename S> void print(pair<F, S> x);",
            "template <typename T, size_t N> struct Tuple;",
            "template <typename T> struct Tuple<T, 1>;",
            "template <typename... Args> void print(tuple<Args...> t);",
            "template <typename... T> void print(priority_queue<T...> pq);",
            "template <typename T> void print(stack<T> st);",
            "template <typename T> void print(queue<T> q);",
            "/* Template Datatypes Definitions */",
            "template <typename T> void print(T &&x) {",
            "\t/*  This works for every container that supports range-based loop",
            "\t\ti.e. vector, set, map, oset, omap, dequeue */",
            "\tint f = 0;",
            "\twriter_out << '{';",
            "\tfor (auto &&i : x)",
            "\t\twriter_out << (f++ ? \",\" : \"\"), print(i);",
            "\twriter_out << \"}\";",
            "}",
            "template <typename T> void print(vector<vector<T>> mat) {",
            "\tint f = 0;",
            "\twriter_out << \"\\n~~~~~\\n\";",
            "\tfor (auto &&i : mat) {",
            "\t\twriter_out << setw(2) << left << f++, print(i), writer_out << \"\\n\";",
            "\t}",
            "\twriter_out << \"~~~~~\\n\";",
            "}",
            "template <typename T, size_t N, size_t M> void print(T (&mat)[N][M]) {",
            "\tint f = 0;",
            "\twriter_out << \"\\n~~~~~\\n\";",
            "\tfor (auto &&i : mat) {",
            "\t\twriter_out << setw(2) << left << f++, print(i), writer_out << \"\\n\";",
            "\t}",
            "\twriter_out << \"~~~~~\\n\";",
            "}",
            "template <typename F, typename S> void print(pair<F, S> x) {",
            "\twriter_out << '(';",
            "\tprint(x.first);",
            "\twriter_out << ',';",
            "\tprint(x.second);",
            "\twriter_out << ')';",
            "}",
            "template <typename T, size_t N> struct Tuple {",
            "\tstatic void printTuple(T t) {",
            "\t\tTuple<T, N - 1>::printTuple(t);",
            "\t\twriter_out << \",\", print(get<N - 1>(t));",
            "\t}",
            "};",
            "template <typename T> struct Tuple<T, 1> {",
            "\tstatic void printTuple(T t) { print(get<0>(t)); }",
            "};",
            "template <typename... Args> void print(tuple<Args...> t) {",
            "\twriter_out << \"(\";",
            "\tTuple<decltype(t), sizeof...(Args)>::printTuple(t);",
            "\twriter_out << \")\";",
            "}",
            "template <typename... T> void print(priority_queue<T...> pq) {",
            "\tint f = 0;",
            "\twriter_out << '{';",
            "\twhile (!pq.empty())",
            "\t\twriter_out << (f++ ? \",\" : \"\"), print(pq.top()), pq.pop();",
            "\twriter_out << \"}\";",
            "}",
            "template <typename T> void print(stack<T> st) {",
            "\tint f = 0;",
            "\twriter_out << '{';",
            "\twhile (!st.empty())",
            "\t\twriter_out << (f++ ? \",\" : \"\"), print(st.top()), st.pop();",
            "\twriter_out << \"}\";",
            "}",
            "template <typename T> void print(queue<T> q) {",
            "\tint f = 0;",
            "\twriter_out << '{';",
            "\twhile (!q.empty())",
            "\t\twriter_out << (f++ ? \",\" : \"\"), print(q.front()), q.pop();",
            "\twriter_out << \"}\";",
            "}",
            "/* Printer functions */",
            "void printer(const char *) {} /* Base Recursive */",
            "template <typename T, typename... V> void printer(const char *names, T &&head, V &&...tail) {",
            "\t/* Using && to capture both lvalues and rvalues */",
            "\tint i = 0;",
            "\tfor (size_t bracket = 0; names[i] != '\\0' and (names[i] != ',' or bracket != 0); i++)",
            "\t\tif (names[i] == '(' or names[i] == '<' or names[i] == '{')",
            "\t\t\tbracket++;",
            "\t\telse if (names[i] == ')' or names[i] == '>' or names[i] == '}')",
            "\t\t\tbracket--;",
            "\twriter_out.write(names, i) << \" = \";",
            "\tprint(head);",
            "\tif (sizeof...(tail))",
            "\t\twriter_out << \" ||\", printer(names + i + 1, tail...);",
            "\telse",
            "\t\twriter_out << \"]\\n\";",
            "}",
            "/* PrinterArr */",
            "void printerArr(const char *) {} /* Base Recursive */",
            "template <typename T, typename... V> void printerArr(const char *names, T arr[], size_t N, V... tail) {",
            "\tsize_t ind = 0;",
            "\tfor (; names[ind] and names[ind] != ','; ind++)",
            "\t\twriter_out << names[ind];",
            "\tfor (ind++; names[ind] and names[ind] != ','; ind++)",
            "\t\t;",
            "\twriter_out << \" = {\";",
            "\tfor (size_t i = 0; i < N; i++)",
            "\t\twriter_out << (i ? \",\" : \"\"), print(arr[i]);",
            "\twriter_out << \"}\";",
            "\tif (sizeof...(tail))",
            "\t\twriter_out << \" ||\", printerArr(names + ind + 1, tail...);",
            "\telse",
            "\t\twriter_out << \"]\\n\";",
            "}",
            "} // namespace __DEBUG_UTIL__",
            "",
            "void err_prefix(string func, int line) {",
            "\twriter_out << \"\\033[0;31m\\u001b[1mDEBUG\\033[0m: \"",
            "\t\t\t   << \"\\u001b[34m\" << func << \"\\033[0m\"",
            "\t\t\t   << \":\"",
            "\t\t\t   << \"\\u001b[34m\" << line << \"\\033[0m: [\";",
            "}",
            "",
            "#ifdef CDEBUG",
            "#define clg(...) err_prefix(__FUNCTION__, __LINE__), __DEBUG_UTIL__::printer(#__VA_ARGS__, __VA_ARGS__)",
            "#else",
            "#define clg(...)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\",
            "\twriter_out << __func__ << \":\" << __LINE__ << \": [\", __DEBUG_UTIL__::printer(#__VA_ARGS__, __VA_ARGS__)",
            "#endif",
            ""
        ]
    },
    "inc_debug": {
        "prefix": "inc_debug",
        "body": [
            "#if defined(LOCAL)",
            "#include \"_debug.h\"",
            "#else",
            "#define clg(...)",
            "#endif"
        ]
    },
    "incdebug": {
        "prefix": "incdebug",
        "body": [
            "#if defined(LOCAL)",
            "#include \"debug.h\"",
            "#else",
            "#define clg(...)",
            "#endif"
        ]
    },
    "fileio": {
        "prefix": "fileio",
        "body": [
            "#ifdef CDEBUG",
            "\tfreopen(\"input.txt\", \"r\", stdin);",
            "\tfreopen(\"output.txt\", \"w\", stdout);",
            "\t// freopen(\"error.txt\", \"w\", stderr);",
            "#endif"
        ]
    },
    "cpp": {
        "prefix": "cpp",
        "body": [
            "#pragma GCC optimize(\"Ofast,unroll-loops,no-stack-protector,fast-math,inline\")",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "using ll = int64_t;",
            "using ull = uint64_t;",
            "using uint = uint32_t;",
            "using i8 = int8_t;",
            "using u8 = uint8_t;",
            "using ish = int16_t;",
            "using ush = uint16_t;",
            "",
            "const ll MOD = 1e9 + 7;",
            "const ll OMOD = 998'244'353;",
            "",
            "void solve() {",
            "\t$0",
            "}",
            "",
            "int32_t main() {",
            "\tios::sync_with_stdio(0);",
            "\tcin.tie(0);",
            "\tint tc = 1;",
            "\tcin >> tc;",
            "\tfor (int i = 1; i <= tc; ++i) {",
            "\t\tsolve();",
            "\t}",
            "\treturn 0;",
            "}"
        ]
    },
    "prps_with_console_debug": {
        "prefix": "prps_with_console_debug",
        "body": [
            "inline namespace IO {",
            "#define SFINAE(x, ...)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   \\",
            "\ttemplate <class, class = void> struct x : std::false_type {};\t\t\t\t\t\t\t\t\t\t\t\\",
            "\ttemplate <class T> struct x<T, std::void_t<__VA_ARGS__>> : std::true_type {}",
            "",
            "SFINAE(DefaultI, decltype(std::cin >> std::declval<T &>()));",
            "SFINAE(DefaultO, decltype(std::cout << std::declval<T &>()));",
            "SFINAE(IsTuple, typename std::tuple_size<T>::type);",
            "SFINAE(Iterable, decltype(std::begin(std::declval<T>())));",
            "",
            "template <auto &is> struct Reader {",
            "\ttemplate <class T> void Impl(T &t) {",
            "\t\tif constexpr (DefaultI<T>::value)",
            "\t\t\tis >> t;",
            "\t\telse if constexpr (Iterable<T>::value) {",
            "\t\t\tfor (auto &x : t)",
            "\t\t\t\tImpl(x);",
            "\t\t} else if constexpr (IsTuple<T>::value) {",
            "\t\t\tstd::apply([this](auto &...args) { (Impl(args), ...); }, t);",
            "\t\t} else",
            "\t\t\tstatic_assert(IsTuple<T>::value, \"No matching type for read\");",
            "\t}",
            "\ttemplate <class... Ts> void read(Ts &...ts) { ((Impl(ts)), ...); }",
            "};",
            "",
            "template <class... Ts> void re(Ts &...ts) { Reader<cin>{}.read(ts...); }",
            "",
            "template <auto &os, bool debug, bool print_nd> struct Writer {",
            "\tstring comma() const { return debug ? \",\" : \"\"; }",
            "\ttemplate <class T> constexpr char Space(const T &) const {",
            "\t\treturn print_nd && (Iterable<T>::value or IsTuple<T>::value) ? '\\n' : ' ';",
            "\t}",
            "\ttemplate <class T> void Impl(T const &t) const {",
            "\t\tif constexpr (DefaultO<T>::value)",
            "\t\t\tos << t;",
            "\t\telse if constexpr (Iterable<T>::value) {",
            "\t\t\tif (debug)",
            "\t\t\t\tos << '{';",
            "\t\t\tint i = 0;",
            "\t\t\tfor (auto &&x : t)",
            "\t\t\t\t((i++) ? (os << comma() << Space(x), Impl(x)) : Impl(x));",
            "\t\t\tif (debug)",
            "\t\t\t\tos << '}';",
            "\t\t} else if constexpr (IsTuple<T>::value) {",
            "\t\t\tif (debug)",
            "\t\t\t\tos << '(';",
            "\t\t\tstd::apply(",
            "\t\t\t\t[this](auto const &...args) {",
            "\t\t\t\t\tint i = 0;",
            "\t\t\t\t\t(((i++) ? (os << comma() << \" \", Impl(args)) : Impl(args)), ...);",
            "\t\t\t\t},",
            "\t\t\t\tt);",
            "\t\t\tif (debug)",
            "\t\t\t\tos << ')';",
            "\t\t} else",
            "\t\t\tstatic_assert(IsTuple<T>::value, \"No matching type for print\");",
            "\t}",
            "\ttemplate <class T> void ImplWrapper(T const &t) const {",
            "\t\tif (debug)",
            "\t\t\tos << \"\\033[0;31m\";",
            "\t\tImpl(t);",
            "\t\tif (debug)",
            "\t\t\tos << \"\\033[0m\";",
            "\t}",
            "\ttemplate <class... Ts> void print(Ts const &...ts) const { ((Impl(ts)), ...); }",
            "\ttemplate <class F, class... Ts>",
            "\tvoid print_with_sep(const std::string &sep, F const &f, Ts const &...ts) const {",
            "\t\tImplWrapper(f), ((os << sep, ImplWrapper(ts)), ...), os << '\\n';",
            "\t}",
            "\tvoid print_with_sep(const std::string &) const { os << '\\n'; }",
            "};",
            "",
            "template <class... Ts> void pr(Ts const &...ts) { Writer<cout, false, true>{}.print(ts...); }",
            "template <class... Ts> void ps(Ts const &...ts) { Writer<cout, false, true>{}.print_with_sep(\" \", ts...); }",
            "} // namespace IO",
            "",
            "inline namespace Debug {",
            "template <typename... Args> void err(Args... args) {",
            "\tWriter<cerr, true, false>{}.print_with_sep(\" | \", args...);",
            "}",
            "template <typename... Args> void errn(Args... args) {",
            "\tWriter<cerr, true, true>{}.print_with_sep(\" | \", args...);",
            "}",
            "",
            "void err_prefix(string func, int line, string args) {",
            "\tcerr << \"\\033[0;31m\\u001b[1mDEBUG\\033[0m\"",
            "\t\t << \" | \"",
            "\t\t << \"\\u001b[34m\" << func << \"\\033[0m\"",
            "\t\t << \":\"",
            "\t\t << \"\\u001b[34m\" << line << \"\\033[0m\"",
            "\t\t << \" - \"",
            "\t\t << \"[\" << args << \"] = \";",
            "}",
            "",
            "#ifdef LOCAL",
            "#define clg(args...) err_prefix(__FUNCTION__, __LINE__, #args), err(args)",
            "#else",
            "#define clg(...)",
            "#endif",
            "} // namespace Debug"
        ]
    },
    "reprps": {
        "prefix": "reprps",
        "body": [
            "inline namespace IO {",
            "#define SFINAE(x, ...)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   \\",
            "\ttemplate <class, class = void> struct x : std::false_type {};\t\t\t\t\t\t\t\t\t\t\t\\",
            "\ttemplate <class T> struct x<T, std::void_t<__VA_ARGS__>> : std::true_type {}",
            "",
            "SFINAE(DefaultI, decltype(std::cin >> std::declval<T &>()));",
            "SFINAE(DefaultO, decltype(std::cout << std::declval<T &>()));",
            "SFINAE(IsTuple, typename std::tuple_size<T>::type);",
            "SFINAE(Iterable, decltype(std::begin(std::declval<T>())));",
            "",
            "template <auto &is> struct Reader {",
            "\ttemplate <class T> void Impl(T &t) {",
            "\t\tif constexpr (DefaultI<T>::value)",
            "\t\t\tis >> t;",
            "\t\telse if constexpr (Iterable<T>::value) {",
            "\t\t\tfor (auto &x : t)",
            "\t\t\t\tImpl(x);",
            "\t\t} else if constexpr (IsTuple<T>::value) {",
            "\t\t\tstd::apply([this](auto &...args) { (Impl(args), ...); }, t);",
            "\t\t} else",
            "\t\t\tstatic_assert(IsTuple<T>::value, \"No matching type for read\");",
            "\t}",
            "\ttemplate <class... Ts> void read(Ts &...ts) { ((Impl(ts)), ...); }",
            "};",
            "",
            "template <class... Ts> void re(Ts &...ts) { Reader<cin>{}.read(ts...); }",
            "",
            "template <auto &os, bool print_nd> struct Writer {",
            "\ttemplate <class T> constexpr char Space(const T &) const {",
            "\t\treturn print_nd && (Iterable<T>::value or IsTuple<T>::value) ? '\\n' : ' ';",
            "\t}",
            "\ttemplate <class T> void Impl(T const &t) const {",
            "\t\tif constexpr (DefaultO<T>::value)",
            "\t\t\tos << t;",
            "\t\telse if constexpr (Iterable<T>::value) {",
            "\t\t\tint i = 0;",
            "\t\t\tfor (auto &&x : t)",
            "\t\t\t\t((i++) ? (os << Space(x), Impl(x)) : Impl(x));",
            "\t\t} else if constexpr (IsTuple<T>::value) {",
            "\t\t\tstd::apply(",
            "\t\t\t\t[this](auto const &...args) {",
            "\t\t\t\t\tint i = 0;",
            "\t\t\t\t\t(((i++) ? (os << \" \", Impl(args)) : Impl(args)), ...);",
            "\t\t\t\t},",
            "\t\t\t\tt);",
            "\t\t} else",
            "\t\t\tstatic_assert(IsTuple<T>::value, \"No matching type for print\");",
            "\t}",
            "\ttemplate <class T> void ImplWrapper(T const &t) const { Impl(t); }",
            "\ttemplate <class... Ts> void print(Ts const &...ts) const { ((Impl(ts)), ...); }",
            "\ttemplate <class F, class... Ts>",
            "\tvoid print_with_sep(const std::string &sep, F const &f, Ts const &...ts) const {",
            "\t\tImplWrapper(f), ((os << sep, ImplWrapper(ts)), ...), os << '\\n';",
            "\t}",
            "\tvoid print_with_sep(const std::string &) const { os << '\\n'; }",
            "};",
            "",
            "template <class... Ts> void pr(Ts const &...ts) { Writer<cout, true>{}.print(ts...); }",
            "template <class... Ts> void ps(Ts const &...ts) { Writer<cout, true>{}.print_with_sep(\" \", ts...); }",
            "} // namespace IO"
        ]
    },
    "inc": {
        "prefix": "inc",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;"
        ]
    },
    "mex": {
        "prefix": "mex",
        "body": [
            "int mex(vector<int> &a) {",
            "\tvector<bool> f(a.size() + 1, 0);",
            "\tfor (int i : a)",
            "\t\tif (i <= (int)a.size())",
            "\t\t\tf[i] = 1;",
            "\tint mex = 0;",
            "\twhile (f[mex])",
            "\t\t++mex;",
            "\treturn mex;",
            "}"
        ]
    },
    "floor_ceil_integer_div": {
        "prefix": "floor_ceil_integer_div",
        "body": [
            "int64_t floor_div(int64_t a, int64_t b) { return a / b - ((a ^ b) < 0 && a % b != 0); }",
            "",
            "int64_t ceil_div(int64_t a, int64_t b) { return a / b + ((a ^ b) > 0 && a % b != 0); }"
        ]
    },
    "miller_rabin": {
        "prefix": "miller_rabin",
        "body": [
            "",
            "uint64_t mod_mul64(uint64_t a, uint64_t b, uint64_t mod) {",
            "\tassert(a < mod && b < mod);",
            "",
            "\tif (mod <= 1LLU << 32)",
            "\t\treturn a * b % mod;",
            "",
            "\tif (mod <= 1LLU << 63) {",
            "\t\tuint64_t q = uint64_t((long double)a * b / mod);",
            "\t\tuint64_t result = a * b - q * mod;",
            "",
            "\t\tif (result > 1LLU << 63)",
            "\t\t\tresult += mod;",
            "\t\telse if (result >= mod)",
            "\t\t\tresult -= mod;",
            "",
            "\t\treturn result;",
            "\t}",
            "",
            "#ifdef __SIZEOF_INT128__",
            "\treturn uint64_t(__uint128_t(a) * b % mod);",
            "#endif",
            "",
            "\tassert(false);",
            "}",
            "",
            "uint64_t mod_pow64(uint64_t a, uint64_t b, uint64_t mod) {",
            "\tuint64_t result = 1;",
            "",
            "\twhile (b > 0) {",
            "\t\tif (b & 1)",
            "\t\t\tresult = mod_mul64(result, a, mod);",
            "",
            "\t\ta = mod_mul64(a, a, mod);",
            "\t\tb >>= 1;",
            "\t}",
            "",
            "\treturn result;",
            "}",
            "",
            "bool miller_rabin(uint64_t n) {",
            "\tif (n < 2)",
            "\t\treturn false;",
            "",
            "\t// Check small primes.",
            "\tfor (uint64_t p : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29})",
            "\t\tif (n % p == 0)",
            "\t\t\treturn n == p;",
            "",
            "\t// https://miller-rabin.appspot.com/",
            "\tauto get_miller_rabin_bases = [&]() -> vector<uint64_t> {",
            "\t\tif (n < 341531)",
            "\t\t\treturn {9345883071009581737LLU};",
            "\t\tif (n < 1050535501)",
            "\t\t\treturn {336781006125, 9639812373923155};",
            "\t\tif (n < 350269456337)",
            "\t\t\treturn {4230279247111683200, 14694767155120705706LLU, 16641139526367750375LLU};",
            "\t\tif (n < 55245642489451)",
            "\t\t\treturn {2, 141889084524735, 1199124725622454117, 11096072698276303650LLU};",
            "\t\tif (n < 7999252175582851)",
            "\t\t\treturn {2, 4130806001517, 149795463772692060, 186635894390467037, 3967304179347715805};",
            "\t\tif (n < 585226005592931977)",
            "\t\t\treturn {2,",
            "\t\t\t\t\t123635709730000,",
            "\t\t\t\t\t9233062284813009,",
            "\t\t\t\t\t43835965440333360,",
            "\t\t\t\t\t761179012939631437,",
            "\t\t\t\t\t1263739024124850375};",
            "\t\treturn {2, 325, 9375, 28178, 450775, 9780504, 1795265022};",
            "\t};",
            "",
            "\tint r = __builtin_ctzll(n - 1);",
            "\tuint64_t d = (n - 1) >> r;",
            "",
            "\tfor (uint64_t a : get_miller_rabin_bases()) {",
            "\t\tif (a % n == 0)",
            "\t\t\tcontinue;",
            "",
            "\t\tuint64_t x = mod_pow64(a % n, d, n);",
            "",
            "\t\tif (x == 1 || x == n - 1)",
            "\t\t\tcontinue;",
            "",
            "\t\tfor (int i = 0; i < r - 1 && x != n - 1; i++)",
            "\t\t\tx = mod_mul64(x, x, n);",
            "",
            "\t\tif (x != n - 1)",
            "\t\t\treturn false;",
            "\t}",
            "",
            "\treturn true;",
            "}"
        ]
    },
    "power": {
        "prefix": "power",
        "body": [
            "int64_t power(int64_t a, int64_t b) {",
            "\tint64_t res = 1;",
            "\twhile (b > 0) {",
            "\t\tif (b & 1)",
            "\t\t\tres = res * a;",
            "\t\ta = a * a;",
            "\t\tb >>= 1;",
            "\t}",
            "\treturn res;",
            "}"
        ]
    },
    "pbds": {
        "prefix": "pbds",
        "body": [
            "#include <ext/pb_ds/assoc_container.hpp>",
            "#include <ext/pb_ds/tree_policy.hpp>",
            "",
            "using __gnu_pbds::null_type;",
            "using __gnu_pbds::rb_tree_tag;",
            "using __gnu_pbds::tree;",
            "using __gnu_pbds::tree_order_statistics_node_update;",
            "",
            "#undef _GLIBCXX_DEBUG",
            "",
            "template <typename K, typename V, typename Comp = less<K>>",
            "using indexed_map =",
            "\ttree<K, V, Comp, rb_tree_tag, tree_order_statistics_node_update>;",
            "",
            "template <typename K, typename Comp = less<K>>",
            "using indexed_set = indexed_map<K, null_type, Comp>;",
            "",
            "template <typename K, typename V, typename Comp = less_equal<K>>",
            "using indexed_multimap = indexed_map<K, V, Comp>;",
            "",
            "template <typename K, typename Comp = less_equal<K>>",
            "using indexed_multiset = indexed_map<K, null_type, Comp>;"
        ]
    },
    "heap": {
        "prefix": "heap",
        "body": [
            "template <typename T, typename Sequence = vector<T>, typename Compare = less<T>>",
            "using template_heap = priority_queue<T, Sequence, Compare>;",
            "template <typename T> using max_heap = template_heap<T>;",
            "template <typename T> using min_heap = template_heap<T, vector<T>, greater<T>>;"
        ]
    },
    "modpow": {
        "prefix": "modpow",
        "body": [
            "int64_t modpow(int64_t a, int64_t b, int64_t mod) {",
            "\tint64_t res = 1;",
            "\twhile (b > 0) {",
            "\t\tif (b & 1) {",
            "\t\t\tres = res * a;",
            "\t\t\tres %= mod;",
            "\t\t}",
            "\t\ta *= a;",
            "\t\ta %= mod;",
            "\t\tb >>= 1;",
            "\t}",
            "\treturn res;",
            "}"
        ]
    },
    "pfactor": {
        "prefix": "pfactor",
        "body": [
            "map<int64_t, int> prime_factors(int64_t number) {",
            "\tmap<int64_t, int> factors;",
            "\twhile (number % 2 == 0) {",
            "\t\tfactors[2]++;",
            "\t\tnumber = number / 2;",
            "\t}",
            "\tfor (int64_t i = 3; i * i <= number; i += 2) {",
            "\t\twhile (number % i == 0) {",
            "\t\t\tfactors[i]++;",
            "\t\t\tnumber = number / i;",
            "\t\t}",
            "\t}",
            "\tif (number > 2)",
            "\t\tfactors[number]++;",
            "\treturn factors;",
            "}"
        ]
    },
    "inverse": {
        "prefix": "inverse",
        "body": [
            "int64_t inverse(int64_t a, int64_t mod) {",
            "\ta %= mod;",
            "\tif (a < 0)",
            "\t\ta += mod;",
            "\tint64_t b = mod, u = 0, v = 1;",
            "\twhile (a) {",
            "\t\tll t = b / a;",
            "\t\tb -= t * a;",
            "\t\tswap(a, b);",
            "\t\tu -= t * v;",
            "\t\tswap(u, v);",
            "\t}",
            "\tassert(b == 1);",
            "\tif (u < 0)",
            "\t\tu += mod;",
            "\treturn u;",
            "}"
        ]
    },
    "dst": {
        "prefix": "dst",
        "body": [
            "template <typename T, typename F> class DisjointSparseTable {",
            "  public:",
            "\tint n;",
            "\tvector<vector<T>> mat;",
            "\tF func;",
            "",
            "\tDisjointSparseTable(const vector<T> &a, const F &f)",
            "\t\t: n(int(a.size())), func(f) {",
            "\t\tmat.push_back(a);",
            "\t\tfor (int p = 1; (1 << p) < n; p++) {",
            "\t\t\tmat.emplace_back(n);",
            "\t\t\tfor (int mid = 1 << p; mid < n; mid += 1 << (p + 1)) {",
            "\t\t\t\tmat[p][mid - 1] = a[mid - 1];",
            "\t\t\t\tfor (int j = mid - 2; j >= mid - (1 << p); j--) {",
            "\t\t\t\t\tmat[p][j] = func(a[j], mat[p][j + 1]);",
            "\t\t\t\t}",
            "\t\t\t\tmat[p][mid] = a[mid];",
            "\t\t\t\tfor (int j = mid + 1; j < min(n, mid + (1 << p)); j++) {",
            "\t\t\t\t\tmat[p][j] = func(mat[p][j - 1], a[j]);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\t//[l, r)",
            "\tT Query(int l, int r) const {",
            "\t\tassert(0 <= l && l < r && r <= n);",
            "\t\tif (r - l == 1) {",
            "\t\t\treturn mat[0][l];",
            "\t\t}",
            "\t\tint p = bit_width(unsigned(l ^ (r - 1))) - 1;",
            "\t\treturn func(mat[p][l], mat[p][r - 1]);",
            "\t}",
            "};",
            ""
        ]
    },
    "sparse": {
        "prefix": "sparse",
        "body": [
            "template <typename T, typename F> class SparseTable {",
            "  public:",
            "\tint n;",
            "\tvector<vector<T>> mat;",
            "\tF func;",
            "",
            "\tSparseTable(const vector<T> &a, const F &f) : func(f) {",
            "\t\tn = static_cast<int>(a.size());",
            "\t\tint max_log = 32 - __builtin_clz(n);",
            "\t\tmat.resize(max_log);",
            "\t\tmat[0] = a;",
            "\t\tfor (int j = 1; j < max_log; j++) {",
            "\t\t\tmat[j].resize(n - (1 << j) + 1);",
            "\t\t\tfor (int i = 0; i <= n - (1 << j); i++) {",
            "\t\t\t\tmat[j][i] = func(mat[j - 1][i], mat[j - 1][i + (1 << (j - 1))]);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\t//[from, to]",
            "\tT get(int from, int to) const {",
            "\t\tassert(0 <= from && from <= to && to <= n - 1);",
            "\t\tint lg = 32 - __builtin_clz(to - from + 1) - 1;",
            "\t\treturn func(mat[lg][from], mat[lg][to - (1 << lg) + 1]);",
            "\t}",
            "};"
        ]
    },
    "time": {
        "prefix": "time",
        "body": [
            "#define start\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\",
            "\tusing namespace chrono;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \\",
            "\tauto start_time = high_resolution_clock::now();",
            "",
            "#define stop\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\",
            "\tauto stop_time = high_resolution_clock::now();\t\t\t\t\t\t\t\t\t\t\t\t\t\t   \\",
            "\tauto duration = duration_cast<milliseconds>(stop_time - start_time);\t\t\t\t\t\t\t\t\t \\",
            "\tcerr << \"[Time Taken\" << \" = \" << duration << \"]\" << endl << endl;",
            ""
        ]
    },
    "mint": {
        "prefix": "mint",
        "body": [
            "",
            "template <typename T> T inverse(T a, T m) {",
            "\tT u = 0, v = 1;",
            "\twhile (a != 0) {",
            "\t\tT t = m / a;",
            "\t\tm -= t * a;",
            "\t\tswap(a, m);",
            "\t\tu -= t * v;",
            "\t\tswap(u, v);",
            "\t}",
            "\tassert(m == 1);",
            "\treturn u;",
            "}",
            "",
            "template <typename T> class Modular {",
            "  public:",
            "\tusing Type = typename decay<decltype(T::value)>::type;",
            "",
            "\tconstexpr Modular() : value() {}",
            "\ttemplate <typename U> Modular(const U &x) { value = normalize(x); }",
            "",
            "\ttemplate <typename U> static Type normalize(const U &x) {",
            "\t\tType v;",
            "\t\tif (-mod() <= x && x < mod())",
            "\t\t\tv = static_cast<Type>(x);",
            "\t\telse",
            "\t\t\tv = static_cast<Type>(x % mod());",
            "\t\tif (v < 0)",
            "\t\t\tv += mod();",
            "\t\treturn v;",
            "\t}",
            "",
            "\tconst Type &operator()() const { return value; }",
            "\ttemplate <typename U> explicit operator U() const { return static_cast<U>(value); }",
            "\tconstexpr static Type mod() { return T::value; }",
            "",
            "\tModular &operator+=(const Modular &other) {",
            "\t\tvalue += other.value;",
            "\t\tvalue -= (value >= mod()) * mod();",
            "\t\treturn *this;",
            "\t}",
            "\tModular &operator-=(const Modular &other) {",
            "\t\tvalue -= other.value;",
            "\t\tvalue += (value < 0) * mod();",
            "\t\treturn *this;",
            "\t}",
            "\ttemplate <typename U> Modular &operator+=(const U &other) { return *this += Modular(other); }",
            "\ttemplate <typename U> Modular &operator-=(const U &other) { return *this -= Modular(other); }",
            "\tModular &operator++() { return *this += 1; }",
            "\tModular &operator--() { return *this -= 1; }",
            "\tModular operator++(int) {",
            "\t\tModular result(*this);",
            "\t\t*this += 1;",
            "\t\treturn result;",
            "\t}",
            "\tModular operator--(int) {",
            "\t\tModular result(*this);",
            "\t\t*this -= 1;",
            "\t\treturn result;",
            "\t}",
            "\tModular operator-() const { return Modular(-value); }",
            "",
            "\ttemplate <typename U = T>",
            "\ttypename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type &",
            "\toperator*=(const Modular &rhs) {",
            "\t\tvalue = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));",
            "\t\treturn *this;",
            "\t}",
            "\ttemplate <typename U = T>",
            "\ttypename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type &",
            "\toperator*=(const Modular &rhs) {",
            "\t\tint64_t q = int64_t(static_cast<long double>(value) * rhs.value / mod());",
            "\t\tvalue = normalize(value * rhs.value - q * mod());",
            "\t\treturn *this;",
            "\t}",
            "\ttemplate <typename U = T>",
            "\ttypename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type &",
            "\toperator*=(const Modular &rhs) {",
            "\t\tvalue = normalize(value * rhs.value);",
            "\t\treturn *this;",
            "\t}",
            "",
            "\tModular &operator/=(const Modular &other) { return *this *= Modular(inverse(other.value, mod())); }",
            "",
            "\tfriend const Type &abs(const Modular &x) { return x.value; }",
            "",
            "\ttemplate <typename U> friend bool operator==(const Modular<U> &lhs, const Modular<U> &rhs);",
            "",
            "\ttemplate <typename U> friend bool operator<(const Modular<U> &lhs, const Modular<U> &rhs);",
            "",
            "\ttemplate <typename V, typename U> friend V &operator>>(V &stream, Modular<U> &number);",
            "",
            "  private:",
            "\tType value;",
            "};",
            "",
            "template <typename T> bool operator==(const Modular<T> &lhs, const Modular<T> &rhs) {",
            "\treturn lhs.value == rhs.value;",
            "}",
            "template <typename T, typename U> bool operator==(const Modular<T> &lhs, U rhs) {",
            "\treturn lhs == Modular<T>(rhs);",
            "}",
            "template <typename T, typename U> bool operator==(U lhs, const Modular<T> &rhs) {",
            "\treturn Modular<T>(lhs) == rhs;",
            "}",
            "",
            "template <typename T> bool operator!=(const Modular<T> &lhs, const Modular<T> &rhs) { return !(lhs == rhs); }",
            "template <typename T, typename U> bool operator!=(const Modular<T> &lhs, U rhs) { return !(lhs == rhs); }",
            "template <typename T, typename U> bool operator!=(U lhs, const Modular<T> &rhs) { return !(lhs == rhs); }",
            "",
            "template <typename T> bool operator<(const Modular<T> &lhs, const Modular<T> &rhs) {",
            "\treturn lhs.value < rhs.value;",
            "}",
            "",
            "template <typename T> Modular<T> operator+(const Modular<T> &lhs, const Modular<T> &rhs) {",
            "\treturn Modular<T>(lhs) += rhs;",
            "}",
            "template <typename T, typename U> Modular<T> operator+(const Modular<T> &lhs, U rhs) {",
            "\treturn Modular<T>(lhs) += rhs;",
            "}",
            "template <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T> &rhs) {",
            "\treturn Modular<T>(lhs) += rhs;",
            "}",
            "",
            "template <typename T> Modular<T> operator-(const Modular<T> &lhs, const Modular<T> &rhs) {",
            "\treturn Modular<T>(lhs) -= rhs;",
            "}",
            "template <typename T, typename U> Modular<T> operator-(const Modular<T> &lhs, U rhs) {",
            "\treturn Modular<T>(lhs) -= rhs;",
            "}",
            "template <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T> &rhs) {",
            "\treturn Modular<T>(lhs) -= rhs;",
            "}",
            "",
            "template <typename T> Modular<T> operator*(const Modular<T> &lhs, const Modular<T> &rhs) {",
            "\treturn Modular<T>(lhs) *= rhs;",
            "}",
            "template <typename T, typename U> Modular<T> operator*(const Modular<T> &lhs, U rhs) {",
            "\treturn Modular<T>(lhs) *= rhs;",
            "}",
            "template <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T> &rhs) {",
            "\treturn Modular<T>(lhs) *= rhs;",
            "}",
            "",
            "template <typename T> Modular<T> operator/(const Modular<T> &lhs, const Modular<T> &rhs) {",
            "\treturn Modular<T>(lhs) /= rhs;",
            "}",
            "template <typename T, typename U> Modular<T> operator/(const Modular<T> &lhs, U rhs) {",
            "\treturn Modular<T>(lhs) /= rhs;",
            "}",
            "template <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T> &rhs) {",
            "\treturn Modular<T>(lhs) /= rhs;",
            "}",
            "",
            "template <typename T, typename U> Modular<T> power(const Modular<T> &a, const U &b) {",
            "\tassert(b >= 0);",
            "\tModular<T> x = a, res = 1;",
            "\tU p = b;",
            "\twhile (p > 0) {",
            "\t\tif (p & 1)",
            "\t\t\tres *= x;",
            "\t\tx *= x;",
            "\t\tp >>= 1;",
            "\t}",
            "\treturn res;",
            "}",
            "",
            "template <typename T> bool IsZero(const Modular<T> &number) { return number() == 0; }",
            "",
            "template <typename T> string to_string(const Modular<T> &number) { return to_string(number()); }",
            "",
            "template <typename U, typename T> U &operator<<(U &stream, const Modular<T> &number) {",
            "\treturn stream << number();",
            "}",
            "",
            "template <typename U, typename T> U &operator>>(U &stream, Modular<T> &number) {",
            "\ttypename common_type<typename Modular<T>::Type, int64_t>::type x;",
            "\tstream >> x;",
            "\tnumber.value = Modular<T>::normalize(x);",
            "\treturn stream;",
            "}",
            "",
            "constexpr int md = $0;",
            "using mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;",
            ""
        ]
    },
    "prps_simple": {
        "prefix": "prps_simple",
        "body": [
            "void ps() { cout << \"\\n\"; }",
            "template <class H, class... T> void ps(const H &h, const T &...t) {",
            "\tcout << h;",
            "\tif (sizeof...(t))",
            "\t\tcout << ' ';",
            "\tps(t...);",
            "}",
            "",
            "void pr() { cout << \"\"; }",
            "template <class H, class... T> void pr(const H &h, const T &...t) {",
            "\tcout << h;",
            "\tpr(t...);",
            "}"
        ]
    },
    "ispowerofn": {
        "prefix": "ispowerofn",
        "body": [
            "bool is_power_of_n(int64_t number, int64_t N) { ",
            "\tif(number == 0 || (number!=1 && N == 0))",
            "\t\treturn false; ",
            "\telse if(N == 1)",
            "\t\treturn true;",
            "\t",
            "\twhile(number != 1) {  ",
            "\t\tif(number % N != 0)",
            "\t\t\treturn false; ",
            "\t\tnumber = number / N;  ",
            "\t} ",
            "\treturn true; ",
            "}",
            "",
            "int64_t log_a_to_base_b(int64_t a, int64_t b) { return log2(a) / log2(b); }"
        ]
    },
    "divisors": {
        "prefix": "divisors",
        "body": [
            "template <typename T>",
            "vector<T> divisors(T number) {",
            "\tvector<T> ans;",
            "\tfor (T i = 1; i * i <= number; ++i) {",
            "\t\tif (number % i == 0) {",
            "\t\t\tif (number / i == i) {",
            "\t\t\t\tans.push_back(i);",
            "\t\t\t} else {",
            "\t\t\t\tans.push_back(i);",
            "\t\t\t\tans.push_back(number / i);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\t//unsorted",
            "\treturn ans;",
            "}"
        ]
    },
    "touristfactorizer": {
        "prefix": "touristfactorizer",
        "body": [
            "",
            "template <typename T> T inverse(T a, T m) {",
            "\tT u = 0, v = 1;",
            "\twhile (a != 0) {",
            "\t\tT t = m / a;",
            "\t\tm -= t * a;",
            "\t\tswap(a, m);",
            "\t\tu -= t * v;",
            "\t\tswap(u, v);",
            "\t}",
            "\tassert(m == 1);",
            "\treturn u;",
            "}",
            "",
            "template <typename T> class Modular {",
            "  public:",
            "\tusing Type = typename decay<decltype(T::value)>::type;",
            "",
            "\tconstexpr Modular() : value() {}",
            "\ttemplate <typename U> Modular(const U &x) { value = normalize(x); }",
            "",
            "\ttemplate <typename U> static Type normalize(const U &x) {",
            "\t\tType v;",
            "\t\tif (-mod() <= x && x < mod())",
            "\t\t\tv = static_cast<Type>(x);",
            "\t\telse",
            "\t\t\tv = static_cast<Type>(x % mod());",
            "\t\tif (v < 0)",
            "\t\t\tv += mod();",
            "\t\treturn v;",
            "\t}",
            "",
            "\tconst Type &operator()() const { return value; }",
            "\ttemplate <typename U> explicit operator U() const { return static_cast<U>(value); }",
            "\tconstexpr static Type mod() { return T::value; }",
            "",
            "\tModular &operator+=(const Modular &other) {",
            "\t\tvalue += other.value;",
            "\t\tvalue -= (value >= mod()) * mod();",
            "\t\treturn *this;",
            "\t}",
            "\tModular &operator-=(const Modular &other) {",
            "\t\tvalue -= other.value;",
            "\t\tvalue += (value < 0) * mod();",
            "\t\treturn *this;",
            "\t}",
            "\ttemplate <typename U> Modular &operator+=(const U &other) { return *this += Modular(other); }",
            "\ttemplate <typename U> Modular &operator-=(const U &other) { return *this -= Modular(other); }",
            "\tModular &operator++() { return *this += 1; }",
            "\tModular &operator--() { return *this -= 1; }",
            "\tModular operator++(int) {",
            "\t\tModular result(*this);",
            "\t\t*this += 1;",
            "\t\treturn result;",
            "\t}",
            "\tModular operator--(int) {",
            "\t\tModular result(*this);",
            "\t\t*this -= 1;",
            "\t\treturn result;",
            "\t}",
            "\tModular operator-() const { return Modular(-value); }",
            "",
            "\ttemplate <typename U = T>",
            "\ttypename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type &",
            "\toperator*=(const Modular &rhs) {",
            "\t\tvalue = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));",
            "\t\treturn *this;",
            "\t}",
            "\ttemplate <typename U = T>",
            "\ttypename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type &",
            "\toperator*=(const Modular &rhs) {",
            "\t\tint64_t q = int64_t(static_cast<long double>(value) * rhs.value / mod());",
            "\t\tvalue = normalize(value * rhs.value - q * mod());",
            "\t\treturn *this;",
            "\t}",
            "\ttemplate <typename U = T>",
            "\ttypename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type &",
            "\toperator*=(const Modular &rhs) {",
            "\t\tvalue = normalize(value * rhs.value);",
            "\t\treturn *this;",
            "\t}",
            "",
            "\tModular &operator/=(const Modular &other) { return *this *= Modular(inverse(other.value, mod())); }",
            "",
            "\tfriend const Type &abs(const Modular &x) { return x.value; }",
            "",
            "\ttemplate <typename U> friend bool operator==(const Modular<U> &lhs, const Modular<U> &rhs);",
            "",
            "\ttemplate <typename U> friend bool operator<(const Modular<U> &lhs, const Modular<U> &rhs);",
            "",
            "\ttemplate <typename V, typename U> friend V &operator>>(V &stream, Modular<U> &number);",
            "",
            "  private:",
            "\tType value;",
            "};",
            "",
            "template <typename T> bool operator==(const Modular<T> &lhs, const Modular<T> &rhs) {",
            "\treturn lhs.value == rhs.value;",
            "}",
            "template <typename T, typename U> bool operator==(const Modular<T> &lhs, U rhs) {",
            "\treturn lhs == Modular<T>(rhs);",
            "}",
            "template <typename T, typename U> bool operator==(U lhs, const Modular<T> &rhs) {",
            "\treturn Modular<T>(lhs) == rhs;",
            "}",
            "",
            "template <typename T> bool operator!=(const Modular<T> &lhs, const Modular<T> &rhs) { return !(lhs == rhs); }",
            "template <typename T, typename U> bool operator!=(const Modular<T> &lhs, U rhs) { return !(lhs == rhs); }",
            "template <typename T, typename U> bool operator!=(U lhs, const Modular<T> &rhs) { return !(lhs == rhs); }",
            "",
            "template <typename T> bool operator<(const Modular<T> &lhs, const Modular<T> &rhs) {",
            "\treturn lhs.value < rhs.value;",
            "}",
            "",
            "template <typename T> Modular<T> operator+(const Modular<T> &lhs, const Modular<T> &rhs) {",
            "\treturn Modular<T>(lhs) += rhs;",
            "}",
            "template <typename T, typename U> Modular<T> operator+(const Modular<T> &lhs, U rhs) {",
            "\treturn Modular<T>(lhs) += rhs;",
            "}",
            "template <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T> &rhs) {",
            "\treturn Modular<T>(lhs) += rhs;",
            "}",
            "",
            "template <typename T> Modular<T> operator-(const Modular<T> &lhs, const Modular<T> &rhs) {",
            "\treturn Modular<T>(lhs) -= rhs;",
            "}",
            "template <typename T, typename U> Modular<T> operator-(const Modular<T> &lhs, U rhs) {",
            "\treturn Modular<T>(lhs) -= rhs;",
            "}",
            "template <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T> &rhs) {",
            "\treturn Modular<T>(lhs) -= rhs;",
            "}",
            "",
            "template <typename T> Modular<T> operator*(const Modular<T> &lhs, const Modular<T> &rhs) {",
            "\treturn Modular<T>(lhs) *= rhs;",
            "}",
            "template <typename T, typename U> Modular<T> operator*(const Modular<T> &lhs, U rhs) {",
            "\treturn Modular<T>(lhs) *= rhs;",
            "}",
            "template <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T> &rhs) {",
            "\treturn Modular<T>(lhs) *= rhs;",
            "}",
            "",
            "template <typename T> Modular<T> operator/(const Modular<T> &lhs, const Modular<T> &rhs) {",
            "\treturn Modular<T>(lhs) /= rhs;",
            "}",
            "template <typename T, typename U> Modular<T> operator/(const Modular<T> &lhs, U rhs) {",
            "\treturn Modular<T>(lhs) /= rhs;",
            "}",
            "template <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T> &rhs) {",
            "\treturn Modular<T>(lhs) /= rhs;",
            "}",
            "",
            "template <typename T, typename U> Modular<T> power(const Modular<T> &a, const U &b) {",
            "\tassert(b >= 0);",
            "\tModular<T> x = a, res = 1;",
            "\tU p = b;",
            "\twhile (p > 0) {",
            "\t\tif (p & 1)",
            "\t\t\tres *= x;",
            "\t\tx *= x;",
            "\t\tp >>= 1;",
            "\t}",
            "\treturn res;",
            "}",
            "",
            "template <typename T> bool IsZero(const Modular<T> &number) { return number() == 0; }",
            "",
            "template <typename T> string to_string(const Modular<T> &number) { return to_string(number()); }",
            "",
            "template <typename U, typename T> U &operator<<(U &stream, const Modular<T> &number) {",
            "\treturn stream << number();",
            "}",
            "",
            "template <typename U, typename T> U &operator>>(U &stream, Modular<T> &number) {",
            "\ttypename common_type<typename Modular<T>::Type, int64_t>::type x;",
            "\tstream >> x;",
            "\tnumber.value = Modular<T>::normalize(x);",
            "\treturn stream;",
            "}",
            "",
            "namespace factorizer {",
            "",
            "template <typename T> struct FactorizerVarMod {",
            "\tstatic T value;",
            "};",
            "template <typename T> T FactorizerVarMod<T>::value;",
            "",
            "template <typename T> bool IsPrime(T n, const vector<T> &bases) {",
            "\tif (n < 2) {",
            "\t\treturn false;",
            "\t}",
            "\tvector<T> small_primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};",
            "\tfor (const T &x : small_primes) {",
            "\t\tif (n % x == 0) {",
            "\t\t\treturn n == x;",
            "\t\t}",
            "\t}",
            "\tif (n < 31 * 31) {",
            "\t\treturn true;",
            "\t}",
            "\tint s = 0;",
            "\tT d = n - 1;",
            "\twhile ((d & 1) == 0) {",
            "\t\td >>= 1;",
            "\t\ts++;",
            "\t}",
            "\tFactorizerVarMod<T>::value = n;",
            "\tfor (const T &a : bases) {",
            "\t\tif (a % n == 0) {",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tModular<FactorizerVarMod<T>> cur = a;",
            "\t\tcur = power(cur, d);",
            "\t\tif (cur == 1) {",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tbool witness = true;",
            "\t\tfor (int r = 0; r < s; r++) {",
            "\t\t\tif (cur == n - 1) {",
            "\t\t\t\twitness = false;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\tcur *= cur;",
            "\t\t}",
            "\t\tif (witness) {",
            "\t\t\treturn false;",
            "\t\t}",
            "\t}",
            "\treturn true;",
            "}",
            "",
            "bool IsPrime(int64_t n) { return IsPrime(n, {2, 325, 9375, 28178, 450775, 9780504, 1795265022}); }",
            "",
            "bool IsPrime(int32_t n) { return IsPrime(n, {2, 7, 61}); }",
            "",
            "vector<int> least = {0, 1};",
            "vector<int> primes;",
            "int precalculated = 1;",
            "",
            "void RunLinearSieve(int n) {",
            "\tn = max(n, 1);",
            "\tleast.assign(n + 1, 0);",
            "\tprimes.clear();",
            "\tfor (int i = 2; i <= n; i++) {",
            "\t\tif (least[i] == 0) {",
            "\t\t\tleast[i] = i;",
            "\t\t\tprimes.push_back(i);",
            "\t\t}",
            "\t\tfor (int x : primes) {",
            "\t\t\tif (x > least[i] || i * x > n) {",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\tleast[i * x] = x;",
            "\t\t}",
            "\t}",
            "\tprecalculated = n;",
            "}",
            "",
            "void RunSieve(int n) { RunLinearSieve(n); }",
            "",
            "template <typename T>",
            "vector<pair<T, int>> MergeFactors(const vector<pair<T, int>> &a, const vector<pair<T, int>> &b) {",
            "\tvector<pair<T, int>> c;",
            "\tint i = 0;",
            "\tint j = 0;",
            "\twhile (i < (int)a.size() || j < (int)b.size()) {",
            "\t\tif (i < (int)a.size() && j < (int)b.size() && a[i].first == b[j].first) {",
            "\t\t\tc.emplace_back(a[i].first, a[i].second + b[j].second);",
            "\t\t\t++i;",
            "\t\t\t++j;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tif (j == (int)b.size() || (i < (int)a.size() && a[i].first < b[j].first)) {",
            "\t\t\tc.push_back(a[i++]);",
            "\t\t} else {",
            "\t\t\tc.push_back(b[j++]);",
            "\t\t}",
            "\t}",
            "\treturn c;",
            "}",
            "",
            "template <typename T> vector<pair<T, int>> RhoC(const T &n, const T &c) {",
            "\tif (n <= 1) {",
            "\t\treturn {};",
            "\t}",
            "\tif ((n & 1) == 0) {",
            "\t\treturn MergeFactors({{2, 1}}, RhoC(n / 2, c));",
            "\t}",
            "\tif (IsPrime(n)) {",
            "\t\treturn {{n, 1}};",
            "\t}",
            "\tFactorizerVarMod<T>::value = n;",
            "\tModular<FactorizerVarMod<T>> x = 2;",
            "\tModular<FactorizerVarMod<T>> saved = 2;",
            "\tT power = 1;",
            "\tT lam = 1;",
            "\twhile (true) {",
            "\t\tx = x * x + c;",
            "\t\tT g = __gcd((x - saved)(), n);",
            "\t\tif (g != 1) {",
            "\t\t\treturn MergeFactors(RhoC(g, c + 1), RhoC(n / g, c + 1));",
            "\t\t}",
            "\t\tif (power == lam) {",
            "\t\t\tsaved = x;",
            "\t\t\tpower <<= 1;",
            "\t\t\tlam = 0;",
            "\t\t}",
            "\t\tlam++;",
            "\t}",
            "\treturn {};",
            "}",
            "",
            "template <typename T> vector<pair<T, int>> Rho(const T &n) { return RhoC(n, static_cast<T>(1)); }",
            "",
            "template <typename T> vector<pair<T, int>> Factorize(T x) {",
            "\tif (x <= 1) {",
            "\t\treturn {};",
            "\t}",
            "\tif (x <= precalculated) {",
            "\t\tvector<pair<T, int>> ret;",
            "\t\twhile (x > 1) {",
            "\t\t\tif (!ret.empty() && ret.back().first == least[x]) {",
            "\t\t\t\tret.back().second++;",
            "\t\t\t} else {",
            "\t\t\t\tret.emplace_back(least[x], 1);",
            "\t\t\t}",
            "\t\t\tx /= least[x];",
            "\t\t}",
            "\t\treturn ret;",
            "\t}",
            "\tif (x <= static_cast<int64_t>(precalculated) * precalculated) {",
            "\t\tvector<pair<T, int>> ret;",
            "\t\tif (!IsPrime(x)) {",
            "\t\t\tfor (T i : primes) {",
            "\t\t\t\tT t = x / i;",
            "\t\t\t\tif (i > t) {",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t\tif (x == t * i) {",
            "\t\t\t\t\tint cnt = 0;",
            "\t\t\t\t\twhile (x % i == 0) {",
            "\t\t\t\t\t\tx /= i;",
            "\t\t\t\t\t\tcnt++;",
            "\t\t\t\t\t}",
            "\t\t\t\t\tret.emplace_back(i, cnt);",
            "\t\t\t\t\tif (IsPrime(x)) {",
            "\t\t\t\t\t\tbreak;",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\tif (x > 1) {",
            "\t\t\tret.emplace_back(x, 1);",
            "\t\t}",
            "\t\treturn ret;",
            "\t}",
            "\treturn Rho(x);",
            "}",
            "",
            "template <typename T> vector<T> BuildDivisorsFromFactors(const vector<pair<T, int>> &factors) {",
            "\tvector<T> divisors = {1};",
            "\tfor (auto &p : factors) {",
            "\t\tint sz = (int)divisors.size();",
            "\t\tfor (int i = 0; i < sz; i++) {",
            "\t\t\tT cur = divisors[i];",
            "\t\t\tfor (int j = 0; j < p.second; j++) {",
            "\t\t\t\tcur *= p.first;",
            "\t\t\t\tdivisors.push_back(cur);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tsort(divisors.begin(), divisors.end());",
            "\treturn divisors;",
            "}",
            "",
            "} // namespace factorizer",
            ""
        ]
    },
    "touristisprime": {
        "prefix": "touristisprime",
        "body": [
            "bool IsPrime(uint64_t n) {",
            "\tif (n < 2) {",
            "\t\treturn false;",
            "\t}",
            "\tvector<uint32_t> small_primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};",
            "\tfor (uint32_t x : small_primes) {",
            "\t\tif (n == x) {",
            "\t\t\treturn true;",
            "\t\t}",
            "\t\tif (n % x == 0) {",
            "\t\t\treturn false;",
            "\t\t}",
            "\t}",
            "\tif (n < 31 * 31) {",
            "\t\treturn true;",
            "\t}",
            "\tuint32_t s = __builtin_ctzll(n - 1);",
            "\tuint64_t d = (n - 1) >> s;",
            "\tfunction<bool(uint64_t)> witness = [&n, &s, &d](uint64_t a) {",
            "\t\tuint64_t cur = 1, p = d;",
            "\t\twhile (p > 0) {",
            "\t\t\tif (p & 1) {",
            "\t\t\t\tcur = (__uint128_t)cur * a % n;",
            "\t\t\t}",
            "\t\t\ta = (__uint128_t)a * a % n;",
            "\t\t\tp >>= 1;",
            "\t\t}",
            "\t\tif (cur == 1) {",
            "\t\t\treturn false;",
            "\t\t}",
            "\t\tfor (uint32_t r = 0; r < s; r++) {",
            "\t\t\tif (cur == n - 1) {",
            "\t\t\t\treturn false;",
            "\t\t\t}",
            "\t\t\tcur = (__uint128_t)cur * cur % n;",
            "\t\t}",
            "\t\treturn true;",
            "\t};",
            "\tvector<uint64_t> bases_64bit = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};",
            "\tfor (uint64_t a : bases_64bit) {",
            "\t\tif (a % n == 0) {",
            "\t\t\treturn true;",
            "\t\t}",
            "\t\tif (witness(a)) {",
            "\t\t\treturn false;",
            "\t\t}",
            "\t}",
            "\treturn true;",
            "}"
        ]
    },
    "kthroot": {
        "prefix": "kthroot",
        "body": [
            "uint64_t kth_root_integer(uint64_t a, int k) {",
            "\tif (k == 1) return a;",
            "\tauto check = [&](uint32_t x) {",
            "\t\tuint64_t mul = 1;",
            "\t\tfor (int j = 0; j < k; j++) {",
            "\t\t\tif (__builtin_mul_overflow(mul, x, &mul)) return false;",
            "\t\t}",
            "\t\treturn mul <= a;",
            "\t};",
            "\tuint64_t ret = 0;",
            "\tfor (int i = 31; i >= 0; i--) {",
            "\t\tif (check(ret | (1u << i))) ret |= 1u << i;",
            "\t}",
            "\treturn ret;",
            "}"
        ]
    },
    "rng": {
        "prefix": "rng",
        "body": [
            "mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());"
        ]
    },
    "segtree_point": {
        "prefix": "segtree_point",
        "body": [
            "",
            "template <typename T, typename  U> struct segtree {",
            "\tvector<T> tree;",
            "\tvector<T> &given;",
            "\tint n;",
            "\tU op;",
            "\tT dvalue = 0;",
            "\tsegtree(vector<T> &g,const U &opr, T defaultvalue) : given(g), op(opr), dvalue(defaultvalue) {",
            "\t\tn = given.size();",
            "\t\ttree.resize(4 * n);",
            "\t\tbuild(0, 0, n - 1);",
            "\t}",
            "private:",
            "\tvoid build(int idx, int l, int r) {",
            "\t\tif (l == r) {",
            "\t\t\ttree[idx] = given[l];",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tint mid = (l + r) / 2;",
            "\t\tint i = 2 * idx;",
            "\t\tbuild(i + 1, l, mid);",
            "\t\tbuild(i + 2, mid + 1, r);",
            "\t\ttree[idx] = op(tree[i + 1], tree[i + 2]);",
            "\t}",
            "\tT query(int idx, int l, int r, int ql, int qr) {",
            "\t\tif (r < ql || l > qr) {",
            "\t\t\treturn dvalue;",
            "\t\t}",
            "\t\tif (l>= ql && r <= qr) {",
            "\t\t\treturn tree[idx];",
            "\t\t}",
            "\t\tint mid = (l+r)/2;",
            "\t\tint i = 2*idx;",
            "\t\tT lhs = query(i+1, l, mid,ql, qr);",
            "\t\tT rhs = query(i+2, mid+1, r, ql, qr);",
            "\t\treturn op(lhs, rhs);",
            "\t}",
            "\tvoid pointupdate(int idx, int l, int r, int tidx, int dx) {",
            "\t\tif (l == r && l == tidx) {",
            "\t\t\tgiven[l] += dx;",
            "\t\t\ttree[idx] += dx;",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tint mid = (l+r)/2;",
            "\t\tif (tidx <= mid) {",
            "\t\t\tpointupdate(2*idx+1,l, mid, tidx, dx);",
            "\t\t} else {",
            "\t\t\tpointupdate(2*idx+2, mid+1, r, tidx, dx);",
            "\t\t}",
            "\t\ttree[idx] = op(tree[2*idx+1], tree[2*idx+2]);",
            "\t}",
            "\tpublic:",
            "\tint query(int ql, int qr) {",
            "\t\treturn  query(0, 0, n-1, ql, qr);",
            "\t}",
            "\tvoid pointupdate(int idx, int dx) {",
            "\t\tpointupdate(0, 0, n-1, idx, dx);",
            "\t}",
            "};"
        ]
    },
    "doubleendedpriorityqueue": {
        "prefix": "doubleendedpriorityqueue",
        "body": [
            "template <typename T, typename Comp = std::less<T>> struct DoubleEndedPriorityQueue {",
            "\tusing value_type = T;",
            "\tusing compare_type = Comp;",
            "",
            "\tDoubleEndedPriorityQueue() = default;",
            "\tDoubleEndedPriorityQueue(const Comp &comp) : _comp(comp) {}",
            "",
            "\ttemplate <typename InputIterator>",
            "\tDoubleEndedPriorityQueue(InputIterator first, InputIterator last) : _max_heap(first, last) {",
            "\t\tstd::make_heap(_max_heap.begin(), _max_heap.end(), _comp);",
            "\t}",
            "\ttemplate <typename InputIterator>",
            "\tDoubleEndedPriorityQueue(InputIterator first, InputIterator last, const Comp &comp)",
            "\t\t: _comp(comp), _max_heap(first, last) {",
            "\t\tstd::make_heap(_max_heap.begin(), _max_heap.end(), _comp);",
            "\t}",
            "",
            "\ttemplate <typename Iterable, typename = std::void_t<typename Iterable::iterator>>",
            "\tDoubleEndedPriorityQueue(const Iterable &dat) : DoubleEndedPriorityQueue(dat.begin(), dat.end()) {}",
            "\ttemplate <typename Iterable, typename = std::void_t<typename Iterable::iterator>>",
            "\tDoubleEndedPriorityQueue(const Iterable &dat, Comp &comp)",
            "\t\t: DoubleEndedPriorityQueue(dat.begin(), dat.end(), comp) {}",
            "",
            "\tbool empty() const { return size() == 0; }",
            "\tint size() const { return _min_heap.size() + _max_heap.size(); }",
            "",
            "\tvoid push(const value_type &v) {",
            "\t\tif (_min_heap.empty() or _comp(pivot, v)) {",
            "\t\t\t_max_heap.push_back(v);",
            "\t\t\tstd::push_heap(_max_heap.begin(), _max_heap.end(), _comp);",
            "\t\t} else {",
            "\t\t\t_min_heap.push_back(v);",
            "\t\t\tstd::push_heap(_min_heap.begin(), _min_heap.end(), _rev_comp);",
            "\t\t}",
            "\t}",
            "\ttemplate <typename... Args> void emplace(Args &&...args) {",
            "\t\tpush(value_type(std::forward<Args>(args)...));",
            "\t}",
            "",
            "\tconst value_type &max() const {",
            "\t\tassert(size());",
            "\t\treturn _max_heap.size() ? _max_heap.front() : pivot;",
            "\t}",
            "\tconst value_type &min() {",
            "\t\tensure_min_heap_nonempty();",
            "\t\treturn _min_heap.front();",
            "\t}",
            "\tconst value_type &top() const { return max(); }",
            "",
            "\tvalue_type pop_max() {",
            "\t\tensure_max_heap_nonempty();",
            "\t\tstd::pop_heap(_max_heap.begin(), _max_heap.end(), _comp);",
            "\t\tvalue_type res = std::move(_max_heap.back());",
            "\t\t_max_heap.pop_back();",
            "\t\treturn res;",
            "\t}",
            "\tvalue_type pop_min() {",
            "\t\tensure_min_heap_nonempty();",
            "\t\tstd::pop_heap(_min_heap.begin(), _min_heap.end(), _rev_comp);",
            "\t\tvalue_type res = std::move(_min_heap.back());",
            "\t\t_min_heap.pop_back();",
            "\t\treturn res;",
            "\t}",
            "\tvalue_type pop() { return pop_max(); }",
            "",
            "\tstd::vector<value_type> dump_sorted() const {",
            "\t\tstd::vector<value_type> res_l(_min_heap), res_r(_max_heap);",
            "\t\tstd::sort(res_l.begin(), res_l.end(), _comp);",
            "\t\tstd::sort(res_r.begin(), res_r.end(), _comp);",
            "\t\tres_l.reserve(size());",
            "\t\tstd::copy(res_r.begin(), res_r.end(), std::back_inserter(res_l));",
            "\t\treturn res_l;",
            "\t}",
            "",
            "  private:",
            "\tcompare_type _comp;",
            "\tstruct {",
            "\t\tcompare_type *comp;",
            "\t\tbool operator()(const value_type &x, const value_type &y) { return (*comp)(y, x); }",
            "\t} _rev_comp{&_comp};",
            "",
            "\tstd::vector<value_type> _max_heap, _min_heap;",
            "\tvalue_type pivot;",
            "",
            "\tvoid ensure_min_heap_nonempty() {",
            "\t\tconst int siz = size();",
            "\t\tassert(siz);",
            "\t\tif (not _min_heap.empty())",
            "\t\t\treturn;",
            "\t\tif (siz == 1) {",
            "\t\t\tstd::swap(_min_heap, _max_heap);",
            "\t\t\tpivot = _min_heap.front();",
            "\t\t} else {",
            "\t\t\tconst int mid = (siz + 1) >> 1;",
            "\t\t\tstd::nth_element(_max_heap.begin(), _max_heap.begin() + mid - 1, _max_heap.end(), _comp);",
            "\t\t\tpivot = _max_heap[mid - 1];",
            "\t\t\t_min_heap.reserve(mid);",
            "\t\t\tstd::move(_max_heap.begin(), _max_heap.begin() + mid, std::back_inserter(_min_heap));",
            "\t\t\t_max_heap.erase(_max_heap.begin(), _max_heap.begin() + mid);",
            "\t\t\tstd::make_heap(_max_heap.begin(), _max_heap.end(), _comp);",
            "\t\t\tstd::make_heap(_min_heap.begin(), _min_heap.end(), _rev_comp);",
            "\t\t}",
            "\t}",
            "\tvoid ensure_max_heap_nonempty() {",
            "\t\tconst int siz = size();",
            "\t\tassert(siz);",
            "\t\tif (not _max_heap.empty())",
            "\t\t\treturn;",
            "\t\tif (siz == 1) {",
            "\t\t\tstd::swap(_min_heap, _max_heap);",
            "\t\t} else {",
            "\t\t\tconst int mid = siz >> 1;",
            "\t\t\tstd::nth_element(_min_heap.begin(), _min_heap.begin() + mid - 1, _min_heap.end(), _comp);",
            "\t\t\tpivot = _min_heap[mid - 1];",
            "\t\t\t_max_heap.reserve(siz - mid);",
            "\t\t\tstd::move(_min_heap.begin() + mid, _min_heap.end(), std::back_inserter(_max_heap));",
            "\t\t\t_min_heap.erase(_min_heap.begin() + mid, _min_heap.end());",
            "\t\t\tstd::make_heap(_max_heap.begin(), _max_heap.end(), _comp);",
            "\t\t\tstd::make_heap(_min_heap.begin(), _min_heap.end(), _rev_comp);",
            "\t\t}",
            "\t}",
            "};"
        ]
    },
    "rangeset": {
        "prefix": "rangeset",
        "body": [
            "template <typename T, bool merge_adjacent_segment = true> struct RangeSet : public std::map<T, T> {",
            "  public:",
            "\tRangeSet() : _size(0) {}",
            "",
            "\t// O(1)",
            "\tT size() const { return number_of_elements(); }",
            "\t//O(1)",
            "\tT number_of_elements() const { return _size; }",
            "\t// returns the number of ranges in this set (not the number of integers). O(1)",
            "\tint number_of_ranges() const { return std::map<T, T>::size(); }",
            "",
            "\t// returns whether the given integer is in this set or not. O(log N)",
            "\tbool contains(T x) const {",
            "\t\tauto it = this->upper_bound(x);",
            "\t\treturn it != this->begin() and x <= std::prev(it)->second;",
            "\t}",
            "",
            "\t/**",
            "\t * returns the iterator pointing to the range [l, r] in this set s.t. l <= x <= r.",
            "\t * if such a range does not exist, returns `end()`.",
            "\t * O(log N)",
            "\t */",
            "\tauto find_range(T x) const {",
            "\t\tauto it = this->upper_bound(x);",
            "\t\treturn it != this->begin() and x <= (--it)->second ? it : this->end();",
            "\t}",
            "",
            "\t// returns whether `x` and `y` is in this set and in the same range. O(log N)",
            "\tbool in_the_same_range(T x, T y) const {",
            "\t\tauto it = get_containing_range(x);",
            "\t\treturn it != this->end() and it->first <= y and y <= it->second;",
            "\t}",
            "",
            "\t// inserts the range [x, x] and returns the number of integers inserted to this set. O(log N)",
            "\tT insert(T x) { return insert(x, x); }",
            "",
            "\t// inserts the range [l, r] and returns the number of integers inserted to this set. amortized O(log N)",
            "\tT insert(T l, T r) {",
            "\t\tif (l > r)",
            "\t\t\treturn 0;",
            "\t\tauto it = this->upper_bound(l);",
            "\t\tif (it != this->begin() and is_mergeable(std::prev(it)->second, l)) {",
            "\t\t\tit = std::prev(it);",
            "\t\t\tl = std::min(l, it->first);",
            "\t\t}",
            "\t\tT inserted = 0;",
            "\t\tfor (; it != this->end() and is_mergeable(r, it->first); it = std::map<T, T>::erase(it)) {",
            "\t\t\tauto [cl, cr] = *it;",
            "\t\t\tr = std::max(r, cr);",
            "\t\t\tinserted -= cr - cl + 1;",
            "\t\t}",
            "\t\tinserted += r - l + 1;",
            "\t\t(*this)[l] = r;",
            "\t\t_size += inserted;",
            "\t\treturn inserted;",
            "\t}",
            "",
            "\t// erases the range [x, x] and returns the number of intergers erased from this set. O(log N)",
            "\tT erase(T x) { return erase(x, x); }",
            "",
            "\t// erases the range [l, r] and returns the number of intergers erased from this set. amortized O(log N)",
            "\tT erase(T l, T r) {",
            "\t\tif (l > r)",
            "\t\t\treturn 0;",
            "\t\tT tl = l, tr = r;",
            "\t\tauto it = this->upper_bound(l);",
            "\t\tif (it != this->begin() and l <= std::prev(it)->second) {",
            "\t\t\tit = std::prev(it);",
            "\t\t\ttl = it->first;",
            "\t\t}",
            "\t\tT erased = 0;",
            "\t\tfor (; it != this->end() and it->first <= r; it = std::map<T, T>::erase(it)) {",
            "\t\t\tauto [cl, cr] = *it;",
            "\t\t\ttr = cr;",
            "\t\t\terased += cr - cl + 1;",
            "\t\t}",
            "\t\tif (tl < l) {",
            "\t\t\t(*this)[tl] = l - 1;",
            "\t\t\terased -= l - tl;",
            "\t\t}",
            "\t\tif (r < tr) {",
            "\t\t\t(*this)[r + 1] = tr;",
            "\t\t\terased -= tr - r;",
            "\t\t}",
            "\t\t_size -= erased;",
            "\t\treturn erased;",
            "\t}",
            "",
            "\t// returns minimum integer x s.t. x >= lower and x is NOT in this set",
            "\tT minimum_excluded(T lower = 0) const {",
            "\t\tstatic_assert(merge_adjacent_segment);",
            "\t\tauto it = find_range(lower);",
            "\t\treturn it == this->end() ? lower : it->second + 1;",
            "\t}",
            "",
            "\t// returns maximum integer x s.t. x <= upper and x is NOT in this set",
            "\tT maximum_excluded(T upper) const {",
            "\t\tstatic_assert(merge_adjacent_segment);",
            "\t\tauto it = find_range(upper);",
            "\t\treturn it == this->end() ? upper : it->first - 1;",
            "\t}",
            "",
            "  private:",
            "\tT _size;",
            "",
            "\tbool is_mergeable(T cur_r, T next_l) { return next_l <= cur_r + merge_adjacent_segment; }",
            "};"
        ]
    },
    "minmaxheap": {
        "prefix": "minmaxheap",
        "body": [
            "template <typename T> class MinMaxHeap {",
            "  public:",
            "\tMinMaxHeap() = default;",
            "\texplicit MinMaxHeap(const std::vector<T> &v) : heap(v) {",
            "\t\tfor (int i = (int)heap.size() / 2 - 1; i >= 0; --i) {",
            "\t\t\tpushdown(i);",
            "\t\t}",
            "\t}",
            "",
            "\tvoid insert(T x) {",
            "\t\theap.push_back(x);",
            "\t\tpushup(heap.size() - 1);",
            "\t}",
            "",
            "\tT min_element() const {",
            "\t\tassert(!heap.empty());",
            "\t\treturn heap[0];",
            "\t}",
            "",
            "\tT max_element() const {",
            "\t\tassert(!heap.empty());",
            "\t\tif (heap.size() <= 2)",
            "\t\t\treturn heap.back();",
            "\t\treturn std::max(heap[1], heap[2]);",
            "\t}",
            "",
            "\tvoid erase_min() {",
            "\t\tassert(!heap.empty());",
            "\t\theap[0] = heap.back();",
            "\t\theap.pop_back();",
            "\t\tpushdown(0);",
            "\t}",
            "",
            "\tvoid erase_max() {",
            "\t\tassert(!heap.empty());",
            "\t\tif (heap.size() <= 2) {",
            "\t\t\theap.pop_back();",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tif (heap.size() == 3) {",
            "\t\t\theap[1] = std::min(heap[1], heap[2]);",
            "\t\t\theap.pop_back();",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tint i = heap[1] > heap[2] ? 1 : 2;",
            "\t\theap[i] = heap.back();",
            "\t\theap.pop_back();",
            "\t\tpushdown(i);",
            "\t}",
            "",
            "  private:",
            "\tstd::vector<T> heap;",
            "",
            "\tvoid pushdown(int i) {",
            "\t\tint d = std::bit_width((unsigned int)i + 1) - 1;",
            "\t\tint n = heap.size();",
            "",
            "\t\twhile (true) {",
            "\t\t\tint l = 2 * i + 1, r = l + 1;",
            "\t\t\tif (l >= n)",
            "\t\t\t\treturn;",
            "",
            "\t\t\tint m = i;",
            "\t\t\tstd::vector<int> check = {l, r, 2 * l + 1, 2 * l + 2, 2 * r + 1, 2 * r + 2};",
            "\t\t\tfor (int j : check) {",
            "\t\t\t\tif (j < n && ((d % 2) ^ (heap[j] < heap[m])))",
            "\t\t\t\t\tm = j;",
            "\t\t\t}",
            "",
            "\t\t\tif (m >= 2 * l + 1) { ",
            "\t\t\t\tif ((d % 2) ^ (heap[m] < heap[i])) {",
            "\t\t\t\t\tstd::swap(heap[m], heap[i]);",
            "\t\t\t\t\tint p = (m - 1) / 2;",
            "\t\t\t\t\tif ((d % 2) ^ (heap[m] > heap[p]))",
            "\t\t\t\t\t\tstd::swap(heap[m], heap[p]);",
            "\t\t\t\t\ti = m;",
            "\t\t\t\t} else {",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t} else {",
            "\t\t\t\tstd::swap(heap[m], heap[i]);",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\tvoid pushup(int i) {",
            "\t\tif (i == 0)",
            "\t\t\treturn;",
            "\t\tint p = (i - 1) / 2;",
            "\t\tint d = std::bit_width((unsigned int)i + 1) - 1;",
            "\t\tif ((d % 2) ^ (heap[i] > heap[p])) {",
            "\t\t\tstd::swap(heap[i], heap[p]);",
            "\t\t\ti = p;",
            "\t\t\t--d;",
            "\t\t}",
            "\t\twhile (i >= 3) { ",
            "\t\t\tint g = ((i - 1) / 2 - 1) / 2;",
            "\t\t\tif ((d % 2) ^ (heap[i] > heap[g]))",
            "\t\t\t\tbreak;",
            "\t\t\tstd::swap(heap[i], heap[g]);",
            "\t\t\ti = g;",
            "\t\t}",
            "\t}",
            "};"
        ]
    },
    "prime_factorization_using_linear_sieve_returning_vector<pair>": {
        "prefix": "prime_factorize_using_linear_sieve_returning_vector<pair>",
        "body": [
            "",
            "class LinearSieve {",
            "   public:",
            "\tLinearSieve(const int n) : _n(n), min_prime_factor(std::vector<int>(n + 1)) {",
            "\t\tstd::iota(min_prime_factor.begin(), min_prime_factor.end(), 0);",
            "\t\tprime_list.reserve(_n / 20);",
            "\t\tfor (int d = 2; d <= _n; ++d) {",
            "\t\t\tif (min_prime_factor[d] == d) prime_list.push_back(d);",
            "\t\t\tconst int prime_max = std::min(min_prime_factor[d], _n / d);",
            "\t\t\tfor (int prime : prime_list) {",
            "\t\t\t\tif (prime > prime_max) break;",
            "\t\t\t\tmin_prime_factor[prime * d] = prime;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tstd::vector<std::pair<int, int>> factorize(int n) const noexcept {",
            "\t\tassert(0 < n and n <= _n);",
            "\t\tstd::vector<std::pair<int, int>> prime_powers;",
            "\t\twhile (n > 1) {",
            "\t\t\tint p = min_prime_factor[n], c = 0;",
            "\t\t\tdo {",
            "\t\t\t\tn /= p, ++c;",
            "\t\t\t} while (n % p == 0);",
            "\t\t\tprime_powers.emplace_back(p, c);",
            "\t\t}",
            "\t\treturn prime_powers;",
            "\t}",
            "\tconst int _n;",
            "\tstd::vector<int> min_prime_factor;",
            "\tstd::vector<int> prime_list;",
            "};",
            ""
        ]
    },
    "ext_gcd": {
        "prefix": "ext_gcd",
        "body": [
            "",
            "constexpr long long safe_mod(long long x, long long m) {",
            "\tx %= m;",
            "\treturn x < 0 ? x + m : x;",
            "}",
            "",
            "// returns {x,y,g} s.t. ax+by=g=gcd(a,b)>=0.",
            "std::tuple<long long, long long, long long> ext_gcd(long long a, long long b) {",
            "\tlong long x = 1, y = 0;",
            "\tlong long z = 0, w = 1;",
            "\twhile (b) {",
            "\t\tlong long p = a / b, q = a % b;",
            "\t\tx -= y * p, std::swap(x, y);",
            "\t\tz -= w * p, std::swap(z, w);",
            "\t\ta = b, b = q;",
            "\t}",
            "\tif (a < 0) {",
            "\t\tx = -x, z = -z, a = -a;",
            "\t}",
            "\treturn {x, z, a};",
            "}",
            "",
            "// returns {x,g} s.t. a*x=g (mod m)",
            "std::pair<long long, long long> gcd_inv(long long a, long long m) {",
            "\tauto [x, y, g] = ext_gcd(a, m);",
            "\treturn {safe_mod(x, m), g};",
            "}",
            "",
            "// returns x s.t. a*x=1 (mod m) if exists, otherwise throws runtime error.",
            "long long inv_mod(long long a, long long mod) {",
            "\tauto [inv, y, g] = ext_gcd(a, mod);",
            "\tassert(g == 1);",
            "\treturn safe_mod(inv, mod);",
            "}",
            ""
        ]
    },
    "linear_sieve": {
        "prefix": "linear_sieve",
        "body": [
            "vector<int> smallest_factor;",
            "vector<bool> prime;",
            "vector<int> primes;",
            "",
            "void sieve(int maximum) {",
            "\tmaximum = max(maximum, 1);",
            "\tsmallest_factor.assign(maximum + 1, 0);",
            "\tprime.assign(maximum + 1, true);",
            "\tprime[0] = prime[1] = false;",
            "\tprimes = {};",
            "",
            "\tfor (int i = 2; i <= maximum; i++) {",
            "\t\tif (prime[i]) {",
            "\t\t\tsmallest_factor[i] = i;",
            "\t\t\tprimes.push_back(i);",
            "\t\t}",
            "",
            "\t\tfor (int p : primes) {",
            "\t\t\tif (p > smallest_factor[i] || int64_t(i) * p > maximum) break;",
            "",
            "\t\t\tprime[i * p] = false;",
            "\t\t\tsmallest_factor[i * p] = p;",
            "\t\t}",
            "\t}",
            "}"
        ]
    },
    "intervalset": {
        "prefix": "intervalset",
        "body": [
            "",
            "template <typename T> struct IntervalsManagedBySet {",
            "\tusing IntervalsType = std::set<std::pair<T, T>>;",
            "\tIntervalsType intervals{{std::numeric_limits<T>::lowest(), std::numeric_limits<T>::lowest()},",
            "\t\t\t\t\t\t\t{std::numeric_limits<T>::max(), std::numeric_limits<T>::max()}};",
            "",
            "\tIntervalsManagedBySet() = default;",
            "",
            "\tbool contains(const T x) const { return contains(x, x); }",
            "",
            "\tbool contains(const T left, const T right) const { return find(left, right) != intervals.end(); }",
            "",
            "\tstd::pair<typename IntervalsType::const_iterator, bool> erase(const T x) {",
            "\t\ttypename IntervalsType::const_iterator it = intervals.lower_bound({x, x});",
            "\t\tif (it->first == x) {",
            "\t\t\tconst T right = it->second;",
            "\t\t\tit = intervals.erase(it);",
            "\t\t\tif (x + 1 <= right)",
            "\t\t\t\tit = intervals.emplace(x + 1, right).first;",
            "\t\t} else {",
            "\t\t\tit = std::prev(it);",
            "\t\t\tconst auto [left, right] = *it;",
            "\t\t\tif (right < x)",
            "\t\t\t\treturn {std::next(it), false};",
            "\t\t\tintervals.erase(it);",
            "\t\t\tit = std::next(intervals.emplace(left, x - 1).first);",
            "\t\t\tif (x + 1 <= right)",
            "\t\t\t\tit = intervals.emplace(x + 1, right).first;",
            "\t\t}",
            "\t\treturn {it, true};",
            "\t}",
            "",
            "\tstd::pair<typename IntervalsType::const_iterator, T> erase(const T left, const T right) {",
            "\t\tassert(left <= right);",
            "\t\ttypename IntervalsType::const_iterator it = intervals.lower_bound({left, left});",
            "\t\tT res = 0;",
            "\t\tfor (; it->second <= right; it = intervals.erase(it)) {",
            "\t\t\tres += it->second - it->first + 1;",
            "\t\t}",
            "\t\tif (it->first <= right) {",
            "\t\t\tres += right - it->first + 1;",
            "\t\t\tconst T r = it->second;",
            "\t\t\tintervals.erase(it);",
            "\t\t\tit = intervals.emplace(right + 1, r).first;",
            "\t\t}",
            "\t\tif (left <= std::prev(it)->second) {",
            "\t\t\tit = std::prev(it);",
            "\t\t\tconst auto [l, r] = *it;",
            "\t\t\tintervals.erase(it);",
            "\t\t\tif (right < r) {",
            "\t\t\t\tres += right - left + 1;",
            "\t\t\t\tintervals.emplace(right + 1, r);",
            "\t\t\t} else {",
            "\t\t\t\tres += r - left + 1;",
            "\t\t\t}",
            "\t\t\tit = std::next(intervals.emplace(l, left - 1).first);",
            "\t\t}",
            "\t\treturn {it, res};",
            "\t}",
            "",
            "\ttypename IntervalsType::const_iterator find(const T x) const { return find(x, x); }",
            "",
            "\ttypename IntervalsType::const_iterator find(const T left, const T right) const {",
            "\t\ttypename IntervalsType::const_iterator it = intervals.lower_bound({left, left});",
            "\t\tif (left < it->first)",
            "\t\t\tit = std::prev(it);",
            "\t\treturn it->first <= left && right <= it->second ? it : intervals.end();",
            "\t}",
            "",
            "\tstd::pair<typename IntervalsType::const_iterator, bool> insert(const T x) {",
            "\t\ttypename IntervalsType::const_iterator it = intervals.lower_bound({x, x});",
            "\t\tif (it->first == x)",
            "\t\t\treturn {it, false};",
            "\t\tif (x <= std::prev(it)->second)",
            "\t\t\treturn {std::prev(it), false};",
            "\t\tT left = x, right = x;",
            "\t\tif (x + 1 == it->first) {",
            "\t\t\tright = it->second;",
            "\t\t\tit = intervals.erase(it);",
            "\t\t}",
            "\t\tif (std::prev(it)->second == x - 1) {",
            "\t\t\tit = std::prev(it);",
            "\t\t\tleft = it->first;",
            "\t\t\tintervals.erase(it);",
            "\t\t}",
            "\t\treturn {intervals.emplace(left, right).first, true};",
            "\t}",
            "",
            "\tstd::pair<typename IntervalsType::const_iterator, T> insert(T left, T right) {",
            "\t\tassert(left <= right);",
            "\t\ttypename IntervalsType::const_iterator it = intervals.lower_bound({left, left});",
            "\t\tif (left <= std::prev(it)->second) {",
            "\t\t\tit = std::prev(it);",
            "\t\t\tleft = it->first;",
            "\t\t}",
            "\t\tT res = 0;",
            "\t\tif (left == it->first && right <= it->second)",
            "\t\t\treturn {it, res};",
            "\t\tfor (; it->second <= right; it = intervals.erase(it)) {",
            "\t\t\tres -= it->second - it->first + 1;",
            "\t\t}",
            "\t\tif (it->first <= right) {",
            "\t\t\tres -= it->second - it->first + 1;",
            "\t\t\tright = it->second;",
            "\t\t\tit = intervals.erase(it);",
            "\t\t}",
            "\t\tres += right - left + 1;",
            "\t\tif (right + 1 == it->first) {",
            "\t\t\tright = it->second;",
            "\t\t\tit = intervals.erase(it);",
            "\t\t}",
            "\t\tif (std::prev(it)->second == left - 1) {",
            "\t\t\tit = std::prev(it);",
            "\t\t\tleft = it->first;",
            "\t\t\tintervals.erase(it);",
            "\t\t}",
            "\t\treturn {intervals.emplace(left, right).first, res};",
            "\t}",
            "",
            "\tT mex(const T x = 0) const {",
            "\t\tauto it = intervals.lower_bound({x, x});",
            "\t\tif (x <= std::prev(it)->second)",
            "\t\t\tit = std::prev(it);",
            "\t\treturn x < it->first ? x : it->second + 1;",
            "\t}",
            "",
            "\tfriend std::ostream &operator<<(std::ostream &os, const IntervalsManagedBySet &x) {",
            "\t\tif (x.intervals.size() == 2)",
            "\t\t\treturn os;",
            "\t\tauto it = next(x.intervals.begin());",
            "\t\twhile (true) {",
            "\t\t\tos << '[' << it->first << \", \" << it->second << ']';",
            "\t\t\tit = next(it);",
            "\t\t\tif (next(it) == x.intervals.end())",
            "\t\t\t\tbreak;",
            "\t\t\tos << ' ';",
            "\t\t}",
            "\t\treturn os;",
            "\t}",
            "};"
        ]
    },
    "sort_unique": {
        "prefix": "sort_unique",
        "body": [
            "template <typename T> void sort_unique(vector<T> &v) {",
            "\tsort(v.begin(), v.end());",
            "\tv.erase(unique(v.begin(), v.end()), v.end());",
            "}"
        ]
    },
    "prime_factorize_using sieve_returning__map": {
        "prefix": "prime_factorize_using_sieve_returning_map",
        "body": [
            "struct Sieve {",
            "\tstd::vector<int> min_factor;",
            "\tstd::vector<int> primes;",
            "\tSieve(int MAXN) : min_factor(MAXN + 1) {",
            "\t\tfor (int d = 2; d <= MAXN; d++) {",
            "\t\t\tif (!min_factor[d]) {",
            "\t\t\t\tmin_factor[d] = d;",
            "\t\t\t\tprimes.emplace_back(d);",
            "\t\t\t}",
            "\t\t\tfor (const auto &p : primes) {",
            "\t\t\t\tif (p > min_factor[d] or d * p > MAXN)",
            "\t\t\t\t\tbreak;",
            "\t\t\t\tmin_factor[d * p] = p;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\t",
            "\ttemplate <class T> std::map<T, int> factorize(T x) const {",
            "\t\tstd::map<T, int> ret;",
            "\t\tassert(x > 0 and x <= ((long long)min_factor.size() - 1) * ((long long)min_factor.size() - 1));",
            "\t\tfor (const auto &p : primes) {",
            "\t\t\tif (x < T(min_factor.size()))",
            "\t\t\t\tbreak;",
            "\t\t\twhile (!(x % p))",
            "\t\t\t\tx /= p, ret[p]++;",
            "\t\t}",
            "\t\tif (x >= T(min_factor.size()))",
            "\t\t\tret[x]++, x = 1;",
            "\t\twhile (x > 1)",
            "\t\t\tret[min_factor[x]]++, x /= min_factor[x];",
            "\t\treturn ret;",
            "\t}",
            "\t",
            "\t",
            "};",
            "// Sieve sieve((1 << 20));"
        ]
    }
}